********************** TABLESPACE ISSUES*************************
./emctl stop agent
./emctl start agent
./emctl clearstate agent
./emctl upload


netstat -tupl 8823
netstat -tupl | grep 8820
ps -ef | grep 95613/java
ps -ef | grep 95613

********************************
***************casds load job run script*********
select * from casds.load_control;

alter session set nls_date_format='DD-MON-YYYY HH24:MI:SS';

update casds.load_control
set processing_from_time = to_date('2019-09-09 00:00:00', 'yyyy-mm-dd
hh24:mi:ss'),
processing_to_time = to_date('2019-09-09 00:05:00', 'yyyy- mm-dd hh24:mi:ss');
Commit;

*****************

select tablespace_name from dba_tablespaces;

Tablespace [ORABPEL_TDE] is [95.09 percent] full 

select a.tbl "Name",
a.tsz "Total Size",
b.fsz "Free Space",
round((1-(b.fsz/a.tsz))*100) "Pct Used",
round((b.fsz/a.tsz)*100) "Pct Free" 
from 
(select tablespace_name tbl,
sum(bytes)/1024/1024/1024 TSZ 
from dba_data_files
where tablespace_name ='SC51420P_CLRT_INDX' 
group by tablespace_name) a,
(select tablespace_name tblsp,
sum(bytes)/1024/1024/1024 FSZ 
from dab_free_space
where tablespace_name ='SYSAUX' group by tablespace_name) b
Where a.tbl=b.tblsp;


SELECT ROUND(SUM(bytes/1024/1024/1024)) "USED_BYTES_IN_GB" ,
ROUND(SUM(CASE when maxbytes/1024/1024/1024 < bytes/1024/1024/1024 
then bytes/1024/1024/1024 
else maxbytes/1024/1024/1024 end )) "MAX_BYTES_IN_GB",
(ROUND(SUM(CASE when maxbytes/1024/1024/1024 < bytes/1024/1024/1024 
then bytes/1024/1024/1024 
else maxbytes/1024/1024/1024 end ))) - (ROUND(SUM(bytes/1024/1024/1024))) "AVAILABLE_IN_GB" 
from dba_data_files 
where tablespace_name='SYSAUX';


set linesize 300
col FILE_NAME format a70
col tablespace_name format a18
select tablespace_name, FILE_NAME, MAXBYTES/1024/1024/1024, BYTES/1024/1024/1024, AUTOEXTENSIBLE from dba_data_files where tablespace_name='ORAESB_TDE';

set lines 200 pages 2000
select a.tablespace_name,a.alloc_size/1024/1024/1024 Allocated_size,a.cur_size/1024/1024/1024 Current_Size,(u.used+a.file_count*65536)/1024/1024/1024 Used_size,(a.alloc_size-(u.used+a.file_count*65536))/1024/1024/1024 Available_size,((u.used+a.file_count*65536)*100)/a.alloc_size Pct_used from dba_tablespaces t,(select t1.tablespace_name,nvl(sum(s.bytes),0) used from  dba_segments s,dba_tablespaces t1 where t1.tablespace_name=s.tablespace_name(+) group by t1.tablespace_name) u,(select d.tablespace_name,sum(greatest(d.bytes,nvl(d.maxbytes,0))) alloc_size,sum(d.bytes) cur_size,count(*) file_count from dba_data_files d group by d.tablespace_name) a where t.tablespace_name=u.tablespace_name and t.tablespace_name=a.tablespace_name and t.tablespace_name='ORAESB_TDE' order by t.tablespace_name;

select file_name from dba_data_files where tablespace_name='UNDOTBS1';

SELECT name, type, total_mb, free_mb, required_mirror_free_mb, usable_file_mb,trunc(100-(free_mb/total_mb)*100,2) pct_used FROM V$ASM_DISKGROUP;																										
 
SELECT GROUP_NUMBER,NAME,TOTAL_MB/1024,FREE_MB/1024,USABLE_FILE_MB/1024 FROM V$ASM_DISKGROUP;
  
  FILE_NAME
-------------------------------------------------------------------
/fs1/oracle/oradata/niku/sc51377d_clrt_indx_01.dbf

SQL> alter database datafile '/fs1/oracle/oradata/niku/SC51420P_Clrt_indx_01.dbf' autoextend on maxsize 50G;


alter tablespace "UNDOTBS1" add datafile '/fs1/oracle/oradata/niku/undotbs04.dbf ' size 10G autoextend on maxsize 20G;

alter database datafile '********' autoextend on maxsize 25G;

ALTER DATABASE DATAFILE '********.dbf' RESIZE 15G;

ALTER TABLESPACE "$$$$$$" ADD DATAFILE '******.dbf' SIZE 3072M;

Note:For ASM, only diskgroup name is required to add a datafile

ALTER TABLESPACE "$$$$$$" ADD DATAFILE '+DATA' SIZE 5G autoextend on maxsize 32G;

*******************************To see full tablespace status in a database********************************

set lines 1000 pages 10000
SELECT  a.tablespace_name,
    ROUND (((c.BYTES - NVL (b.BYTES, 0)) / c.BYTES) * 100,2) percentage_used,
    c.BYTES/1024/1024/1024 space_allocated,
    ROUND (c.BYTES/1024/1024/1024 - NVL (b.BYTES, 0)/1024/1024/1024,2) space_used,
    ROUND (NVL (b.BYTES, 0)/1024/1024/1024, 2) space_free, 
    c.DATAFILES
  FROM dba_tablespaces a,
       (    SELECT   tablespace_name, 
                  SUM (BYTES) BYTES
           FROM   dba_free_space
       GROUP BY   tablespace_name
       ) b,
      (    SELECT   COUNT (1) DATAFILES, 
                  SUM (BYTES) BYTES, 
                  tablespace_name
           FROM   dba_data_files
       GROUP BY   tablespace_name
    ) c
  WHERE b.tablespace_name(+) = a.tablespace_name 
    AND c.tablespace_name(+) = a.tablespace_name
ORDER BY NVL (((c.BYTES - NVL (b.BYTES, 0)) / c.BYTES), 0) DESC;

****Temp tablespace usage by user*******

COLUMN tablespace FORMAT A20 
COLUMN temp_size FORMAT A20 
COLUMN sid_serial FORMAT A20 
COLUMN username FORMAT A20 
COLUMN program FORMAT A40 
set line 200
SELECT b.tablespace, 
ROUND(((b.blocks*p.value)/1024/1024),2)||'M' AS temp_size, 
a.sid||','||a.serial# AS sid_serial, 
NVL(a.username, '(oracle)') AS username, 
a.program 
FROM v$session a, 
v$sort_usage b, 
v$parameter p 
WHERE p.name = 'db_block_size' 
AND a.saddr = b.session_addr 
ORDER BY b.tablespace, b.blocks;

SELECT b.tablespace, 
ROUND(((b.blocks*p.value)/1024/1024),2)||'M' AS temp_size, 
a.sid||','||a.serial# AS sid_serial, 
NVL(a.username, '(oracle)') AS username, 
a.program 
FROM v$session a, 
v$sort_usage b, 
v$parameter p 
WHERE p.name = 'db_block_size' 
AND a.saddr = b.session_addr 
ORDER BY b.blocks;


------Tablespace growth history----------

COL BEGIN_INTERVAL_TIME FORMAT A30
COL END_INTERVAL_TIME FORMAT A30

SELECT BEGIN_INTERVAL_TIME,END_INTERVAL_TIME,B.NAME,
ROUND((TABLESPACE_SIZE*8*1024)/1024/1024,2) SIZE_MB,
ROUND((TABLESPACE_MAXSIZE*8*1024)/1024/1024,2) MAXSIZE_MB,
ROUND((TABLESPACE_USEDSIZE*8*1024)/1024/1024,2) USEDSIZE_MB
FROM DBA_HIST_TBSPC_SPACE_USAGE A
JOIN V$TABLESPACE B ON (A.TABLESPACE_ID = B.TS#)
JOIN DBA_HIST_SNAPSHOT C ON (A.SNAP_ID = C.SNAP_ID)
WHERE NAME = 'TEMP'
ORDER BY 1 DESC;

SELECT TS#, NAME FROM V$TABLESPACE WHERE NAME='TEMP';


SELECT (TABLESPACE_SIZE*16384)/1024/1024 "TOT MB",(TABLESPACE_USEDSIZE*16384)/1024/1024 "USE MB",RTIME 
FROM DBA_HIST_TBSPC_SPACE_USAGE 
WHERE TABLESPACE_ID = 3
ORDER BY RTIME

------ UNDO USAGE -----------

COL "OS USER" FORMAT A10
COL "DB USER" FORMAT A10
COL "SCHEMA" FORMAT A10
COL "OBJECT NAME" FORMAT A25
COL "OBJECT TYPE" FORMAT A20
COL "RBS NAME" FORMAT A20
SELECT GVS.INST_ID "INSTANCE",
GVS.SID,
GLO.OS_USER_NAME "OS USER",
GLO.ORACLE_USERNAME "DB USER",
DBO.OWNER "SCHEMA",
SUBSTR (DBO.OBJECT_NAME, 1, 30) "OBJECT NAME",
SUBSTR (DBO.OBJECT_TYPE, 1, 10) "OBJECT TYPE",
SUBSTR (DRS.SEGMENT_NAME, 1, 15) "RBS NAME",
GVT.USED_UREC "# OF RECORDS",
GVT.USED_UBLK "# OF BLOCKS",
DRS.TABLESPACE_NAME "TABLESPACE"
FROM
GV$LOCKED_OBJECT GLO,
DBA_OBJECTS DBO,
DBA_ROLLBACK_SEGS DRS,
GV$TRANSACTION GVT,
GV$SESSION GVS
WHERE GLO.OBJECT_ID = DBO.OBJECT_ID
AND GLO.XIDUSN = DRS.SEGMENT_ID
AND GLO.XIDUSN = GVT.XIDUSN
AND GLO.XIDSLOT = GVT.XIDSLOT
AND GVT.ADDR = GVS.TADDR
AND GVT.USED_UBLK > 1000
ORDER BY GVT.USED_UBLK DESC;


SELECT TO_CHAR(S.SID)||','||TO_CHAR(S.SERIAL#) SID_SERIAL,
NVL(S.USERNAME, 'NONE') ORAUSER,
S.PROGRAM,
R.NAME UNDOSEG,
T.USED_UBLK * TO_NUMBER(X.VALUE)/1024||'K' "UNDO"
FROM SYS.V_$ROLLNAME R,
SYS.V_$SESSION S,
SYS.V_$TRANSACTION T,
SYS.V_$PARAMETER X
WHERE S.TADDR = T.ADDR
AND R.USN = T.XIDUSN(+)
AND X.NAME = 'DB_BLOCK_SIZE'
/

select a.used, b.allocated, round((a.used/b.allocated)*100,2) PCT_USED, c.unexpired, d.active from
(select sum(BYTES/1024/102/1024) used from dba_undo_extents where status in ('UNEXPIRED','ACTIVE')) a,
(select sum(bytes/1024/1024/1024)allocated from dba_data_files where tablespace_name like 'UNDOTBS1') b ,
(select sum(bytes/1024/1024/1024) unexpired from dba_undo_extents where status = 'UNEXPIRED') c,
(select sum(bytes/1024/1024/1024) active from dba_undo_extents where status = 'ACTIVE') d;


ACTIVE :- they are being used
UNEXPIRED :- they will not be released until the undo_retention time. 
But if all other extents are used, then oracle may reallocate unexpired blocks
and any session which is trying to read from unexpired block may received "snapshot too old error".
EXPIRED :- here these blocks will be reused, you can consider them as free.

***********************************************************************************************

**********************File system check ************************

select * 
from 
(
SELECT target_name host_name,decode(column_label,'Filesystem Size (MB)','Total_size(MB)','Filesystem Space Available (MB)','Available Space(MB)','Filesystem Space Available (%)','Available (%)') column_label,
key_value "Mountpoint", 
value
FROM mgmt$metric_current 
WHERE target_type = 'host' 
AND regexp_like (target_name , 'sys|pds|prf')
AND metric_name = 'Filesystems' 
and key_value like '/u%data%'
)
pivot  
(max(value)
       for (column_label) in
       ('Total_size(MB)'
      ,'Available Space(MB)'
      ,'Available (%)')
) where "'Available (%)'" <10
******************

COLUMN USERNAME FORMAT A15;
COLUMN SEGMENT_NAME FORMAT A15;
SELECT S.SID , S.USERNAME , T.USED_UBLK, ROUND((T.USED_UBLK*8)/1024) SIZE_IN_MB_8KB_BLOCK_SIZE, ROUND((T.USED_UBLK*16)/1024
) SIZE_IN_MB_16KB_BLOCK_SIZE
FROM V$TRANSACTION T
, V$SESSION S
WHERE 1 = 1
AND T.SES_ADDR = S.SADDR;



SELECT  a.sid, a.username, b.used_urec, b.used_ublk
FROM v$session a, v$transaction b
WHERE a.saddr = b.ses_addr
ORDER BY b.used_ublk DESC;


***Some troubleshooting for space issue***

SQL> select USERNAME,SQL_ID,TABLESPACE,SESSION_NUM from  v$tempseg_usage;

USERNAME   SQL_ID         TABLESPACE    SESSION_NUM
---------- ------------- --------------- -----------
DBSNMP    djj1j2x059xzh     TEMP              20


################# SESSION RELATED ############################

alter session set nls_date_format='DD-MON-YYYY HH24:MI:SS';

select sid,serial#,username,status,logon_time,sql_hash_value from v$session where sid=20

select sid,serial#,username,status,logon_time,sql_hash_value from gv$session where USERNAME='BRM103';

alter system kill session '280,2616' immediate;

col SCHEMANAME format a15
col OSUSER format a12
col STATUS format a10
col PROCESS format 999999
col MACHINE FORMAT A25

select username,status,count(*) from gv$session WHERE TYPE<>'BACKGROUND' and username not in ('SYS','TEMPDBA','DBSNMP') group by username,status;

select username,machine,status,count(*) from gv$session WHERE TYPE<>'BACKGROUND' and username not in ('SYS','TEMPDBA','DBSNMP') group by username,machine,status order by count(*) desc;

select username,machine,status,count(*) from gv$session WHERE TYPE<>'BACKGROUND' and username in ('BRMSYS100') group by username,machine,status order by count(*) desc;


alter session set nls_date_format='DD-MON-YY hh24:mi:ss';
select username,osuser,status,sql_id,machine,program,logon_time from v$session where TYPE<>'BACKGROUND' and username not in ('SYS','TEMPDBA','DBSNMP') and status='INACTIVE';

select username,status,sql_id,machine,count(*) from v$session where TYPE<>'BACKGROUND' and username not in ('SYS','TEMPDBA','DBSNMP') group by username,status,sql_id,machine;

select inst_id,username,status,count(*) from gv$session WHERE TYPE<>'BACKGROUND' and username not in ('SYS','TEMPDBA','DBSNMP') group by inst_id,username,status order by inst_id,count(*);
***************************************
-------------High cpu usage----------------
Displaying top CPU_consuming processes:
#ps aux | head -1; ps aux | sort -rn +2 | head -10 

Displaying top 10 memory-consuming processes:
#ps aux | head -1; ps aux | sort -rn +3 | head 

select
   ss.username,
   se.SID,
   VALUE/100 cpu_usage_seconds
from
   v$session ss,
   v$sesstat se,
   v$statname sn
where
   se.STATISTIC# = sn.STATISTIC#
and
   NAME like '%CPU used by this session%'
and
   se.SID = ss.SID
and
   ss.status='sho ACTIVE'
and
   ss.username is not null
order by VALUE desc;

********************************************
col username form A15
col sid form 9990
col type form A4
col lmode form 990
col request form 990
col id1 form 9999990
col id2 form 9999990

break on id1 skip 1 dup


SELECT sn.username, m.sid, m.type,
   DECODE(m.lmode, 0, 'None'
                 , 1, 'Null'
                 , 2, 'Row Share'
                 , 3, 'Row Excl.'
                 , 4, 'Share'
                 , 5, 'S/Row Excl.'
                 , 6, 'Exclusive'
                 , lmode, ltrim(to_char(lmode,'990'))) lmode,
   DECODE(m.request, 0, 'None'
                 , 1, 'Null'
                 , 2, 'Row Share'
                 , 3, 'Row Excl.'
                 , 4, 'Share'
                 , 5, 'S/Row Excl.'
                 , 6, 'Exclusive'
                 , request, ltrim(to_char(request,'990'))) request,
         m.id1,m.id2
FROM v$session sn, V$lock m
WHERE (sn.sid = m.sid AND m.request != 0)
   OR (sn.sid = m.sid
      AND m.request = 0 AND lmode != 4
      AND (id1, id2 ) IN (SELECT s.id1, s.id2
                          FROM v$lock s
                          WHERE request != 0
                                 AND s.id1 = m.id1
                                 AND s.id2 = m.id2 )
      )
ORDER BY id1,id2, m.request;


select to_char(timestamp_to_scn(to_timestamp(‘08/09/2019 02:36:00’,‘DD/MM/YYYY HH24:MI:SS’))) as scn from dual;


___ Blocking session queries ______
SELECT s.username,s.blocking_session,s.sid,s.serial#,s.seconds_in_wait FROM gv$session s WHERE blocking_session IS NOT NULL order by blocking_session;

select 'alter system kill session '''||a.sid||','||a.serial#||''' immediate;' from gv$session a, gv$process b where status='INACTIVE' and a.paddr=b.addr AND a.username='BRM01';

SELECT distinct a.sql_id ,a.inst_id,a.blocking_session,a.blocking_session_serial#,a.user_id,s.sql_text,a.module,a.sample_time
FROM GV$ACTIVE_SESSION_HISTORY a ,gv$sql s
where a.sql_id=s.sql_id
and blocking_session is not null
and a.user_id <> 0 -- exclude SYS user 
and a.sample_time > '04-oct-2018 09:45' ;

SELECT DECODE(request,0,'Holder: ','Waiter: ')||sid sess,id1, id2, lmode, request, type,
'alter system kill session '''||sid||','||(select serial# from v$session where sid=l.sid) ||'''' "Kill stmt"
FROM V$LOCK l
WHERE (id1, id2, type) IN(SELECT id1, id2, type FROM V$LOCK WHERE request>0)
ORDER BY id1, request
/


SELECT p.program, p.spid, s.sid, s.sql_id, s.status, s.event, s.wait_class, s.status, s.logon_time
FROM v$session s, v$process p
WHERE s.paddr = p.addr
AND p.spid in ('3080408','31195152','21233738','23330938','16842930','27656316','30998544');


select 'alter system kill session '''||a.sid||','||a.serial#||''' immediate;' from gv$session a, v$process b where status='INACTIVE' and a.paddr=b.addr AND a.username='AIA';

SELECT 'alter system kill session '''|| s.sid|| ','|| s.serial#|| ''' immediate;' kill_sid FROM  gv$session s WHERE  username='BRM01' and sql_id='69c6vyk2xp2k9';



-- Find all blocked sessions and who is blocking them
select sid,blocking_session,username,sql_id,event,machine,osuser,program,last_call_et from gv$session where blocking_session > 0;

select * from dba_blockers;
select * from dba_waiters;

-- Find what the blocking session is doing
select sid,blocking_session,username,sql_id,event,state,machine,osuser,program,last_call_et from gv$session where sid=4624;

-- Find the blocked objects
select owner,object_name,object_type from dba_objects where object_id in (select object_id from v$locked_object where session_id=2532 and locked_mode =3);


-- Friendly query for who is blocking who
-- Mostly for versions before v$session had blocking_session column
select s1.inst_id,s2.inst_id,s1.username || '@' || s1.machine
|| ' ( SID=' || s1.sid || ' )  is blocking '
|| s2.username || '@' || s2.machine || ' ( SID=' || s2.sid || ' ) ' AS blocking_status
  from gv$lock l1, gv$session s1, gv$lock l2, gv$session s2
  where s1.sid=l1.sid and s2.sid=l2.sid and s1.inst_id=l1.inst_id and s2.inst_id=l2.inst_id
  and l1.BLOCK=1 and l2.request > 0
  and l1.id1 = l2.id1
  and l2.id2 = l2.id2
order by s1.inst_id;


-- find blocking sessions that were blocking for more than 15 minutes + objects and sql
select s.SID,p.SPID,s.machine,s.username,CTIME/60 as minutes_locking, do.object_name as locked_object, q.sql_text
from v$lock l
join v$session s on l.sid=s.sid
join v$process p on p.addr = s.paddr
join v$locked_object lo on l.SID = lo.SESSION_ID
join dba_objects do on lo.OBJECT_ID = do.OBJECT_ID 
join v$sqlarea q on  s.sql_hash_value = q.hash_value and s.sql_address = q.address
where block=1 and ctime/60>15

-- Check who is blocking who in RAC
SELECT DECODE(request,0,'Holder: ','Waiter: ') || sid sess, id1, id2, lmode, request, type
FROM gv$lock
WHERE (id1, id2, type) IN (
  SELECT id1, id2, type FROM gv$lock WHERE request>0)
ORDER BY id1, request;

-- Check who is blocking who in RAC, including objects
SELECT DECODE(request,0,'Holder: ','Waiter: ') || gv$lock.sid sess, machine, do.object_name as locked_object,id1, id2, lmode, request, gv$lock.type
FROM gv$lock join gv$session on gv$lock.sid=gv$session.sid and gv$lock.inst_id=gv$session.inst_id
join gv$locked_object lo on gv$lock.SID = lo.SESSION_ID and gv$lock.inst_id=lo.inst_id
join dba_objects do on lo.OBJECT_ID = do.OBJECT_ID 
WHERE (id1, id2, gv$lock.type) IN (
  SELECT id1, id2, type FROM gv$lock WHERE request>0)
ORDER BY id1, request;

-- Who is blocking who, with some decoding
select sn.USERNAME,
       m.SID,
       sn.SERIAL#,
       m.TYPE,
       decode(LMODE,
              0, 'None',
              1, 'Null',
              2, 'Row-S (SS)',
              3, 'Row-X (SX)',
              4, 'Share',
              5, 'S/Row-X (SSX)',
              6, 'Exclusive') lock_type,
       decode(REQUEST,
              0, 'None', 
              1, 'Null',
              2, 'Row-S (SS)',
              3, 'Row-X (SX)', 
              4, 'Share', 
              5, 'S/Row-X (SSX)',
              6, 'Exclusive') lock_requested,
       m.ID1,
       m.ID2,
       t.SQL_TEXT
from   v$session sn, 
       v$lock m , 
       v$sqltext t
where t.ADDRESS = sn.SQL_ADDRESS 
and    t.HASH_VALUE = sn.SQL_HASH_VALUE 
and    ((sn.SID = m.SID and m.REQUEST != 0) 
or     (sn.SID = m.SID and m.REQUEST = 0 and LMODE != 4 and (ID1, ID2) in
        (select s.ID1, s.ID2 
         from v$lock S 
         where       REQUEST != 0 
         and s.ID1 = m.ID1 
         and s.ID2 = m.ID2)))
order by sn.USERNAME, sn.SID, t.PIECE

-- Who is blocking who, with some decoding
select OS_USER_NAME os_user,
       PROCESS os_pid,
       ORACLE_USERNAME oracle_user,
       l.SID oracle_id,
       decode(TYPE,
              'MR', 'Media Recovery',
              'RT', 'Redo Thread',
              'UN', 'User Name',
              'TX', 'Transaction',
              'TM', 'DML',
              'UL', 'PL/SQL User Lock',
              'DX', 'Distributed Xaction',
              'CF', 'Control File',
              'IS', 'Instance State',
              'FS', 'File Set',
              'IR', 'Instance Recovery',
              'ST', 'Disk Space Transaction',
              'TS', 'Temp Segment',
              'IV', 'Library Cache Invalidation',
              'LS', 'Log Start or Switch',
              'RW', 'Row Wait',
              'SQ', 'Sequence Number',
              'TE', 'Extend Table',
              'TT', 'Temp Table', type) lock_type,
       decode(LMODE,
              0, 'None',
              1, 'Null',
              2, 'Row-S (SS)',
              3, 'Row-X (SX)',
              4, 'Share',
              5, 'S/Row-X (SSX)',
              6, 'Exclusive', lmode) lock_held,
       decode(REQUEST,
              0, 'None',
              1, 'Null',
              2, 'Row-S (SS)',
              3, 'Row-X (SX)',
              4, 'Share',
              5, 'S/Row-X (SSX)',
              6, 'Exclusive', request) lock_requested,
       decode(BLOCK,
              0, 'Not Blocking',
              1, 'Blocking',
              2, 'Global', block) status,
       OWNER,
       OBJECT_NAME
from   v$locked_object lo,
       dba_objects do,
       v$lock l
where lo.OBJECT_ID = do.OBJECT_ID
AND     l.SID = lo.SESSION_ID
and block=1

*************** Long running queries ******************************

select sid from v$session_wait
where
(event not in ( 'SQL*Net message from client','SQL*Net message to client',
'rdbms ipc message', 'smon timer', 'pmon timer', 'virtual circuit status',
'SQL*Net message from dblink','SQL*Net more data from dblink',
'PL/SQL lock timer','sbtbackup','imm op','jobq slave wait','i/o slave wait',
'sbtwrite2','io done','sbtclose2','sbtinit','sbtinfo2','sbtinit2','Backup: sbtwrite2','Backup: sbtbackup', 'VKTM Logical Idle Wait', 'fbar timer')
 and event not like 'Streams AQ:%')
 and seconds_in_wait > 30
 and sid > 12;

 
SELECT s.username,
       sl.sid,
       sl.last_update_time,
       sl.sql_id,
       target,
       elapsed_seconds,
       time_remaining,
       sq.sql_fulltext
FROM v$session_longops sl
INNER JOIN v$sql sq ON sq.sql_id = sl.sql_id
INNER JOIN v$session s ON sl.SID = s.SID AND sl.serial# = s.serial#
WHERE time_remaining > 0;


col %DONE for a10
col USERNAME for a20
col TARGET for a30
select b.username,a.sid,b.opname,b.target,round(b.SOFAR*100/b.TOTALWORK,0) || '%' as "%DONE",b.TIME_REMAINING,to_char(b.start_time,'YYYY/MM/DD HH24:MI:SS') START_TIME from V$SESSION_LONGOPS b,V$SESSION a where a.sid=b.sid order by 6;
 
*************Long running transaction***********
select * from
(
  select
     opname,start_time,target,sofar,totalwork,units,elapsed_seconds,message
   from
        v$session_longops
  order by start_time desc
)
where rownum <=1;

*****************************************************************************
AWR-- Automatic Workload repository
ASH-- Active session history

How to pull AWR/ASH report from database:
	awrrpt.sql  or  awrddrpt.sql		@$ORACLE_HOME/rdbms/admin/awrrpt.sql
	ashrpt.sql  or  ashddrpt.sql		@$ORACLE_HOME/rdbms/admin/ashrpt.sql

@?/rdbms

@? -- ORACLE_HOME

*****************************************************************************

********************File system*********************************************

du -sk *
ls -lhrt

du -sh *|grep G

find . -name "core.oracle*" -mtime +20 -exec ls -lrt {} +

find . -name "*.trc" -mmin +7 -exec rm -rf {} +

find . -name "aud*" -mtime 15 -exec rm -rf {} +

find . -mtime +7 | xargs rm -Rf

ls -ltr *.trc | grep 'Oct 13 19:' | awk '{print "rm "$9}' | sh ;

ps -ef|grep "LOCAL=NO"| grep prdfin02|grep Apr|awk {'print $2'}
kill -9 `ps -ef|grep "LOCAL=NO"| grep prdfin02|grep Apr|awk {'print $2'}`

*************************************************************************

*************Number of disk to be monitored is larger than 1000*************

Go to the location: /u01/app/middleware/agent_inst/sysman/emd

emagent_storage.config
-> edit
-> increase Disks

Restart the agent 

How to check AGENT details
/u01/app/middleware/agent12c/agent_inst/bin/emctl status agent
/u01/app/middleware/agent12c/agent_inst/bin/emctl start blackout Agent_Restart -nodeLevel -d 01:00
/u01/app/middleware/agent12c/agent_inst/bin/emctl stop agent
/u01/app/middleware/agent12c/agent_inst/bin/emctl clearstate agent
/u01/app/middleware/agent12c/agent_inst/bin/emctl start agent
/u01/app/middleware/agent12c/agent_inst/bin/emctl stop blackout Agent_Restart 
/u01/app/middleware/agent12c/agent_inst/bin/emctl upload agent
*****************************************************************************

*********************crontab info*************************************

Crontab: Min,Hour,Day of month,Month,Day of week

A field may be an asterisk (*), which always stands for "first through last"

Field Descriptions:

minute  hour  dayOfMonth  month  dayOfWeek  command
where:
minute values range from 0 to 59, 
hour values range from 0 to 23, 
dayOfMonth values range from 1 to 31, 
month values range from 1 to 12, 
dayOfWeek values range from 0 to 6, with 0 meaning Sunday 
Field Values:


****crontab backup****

crontab -l > crontab_date_bkp

****How to restore****

crontab crontab_date_bkp

run {
allocate channel dev1 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
allocate channel dev2 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
allocate channel dev3 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
allocate channel dev4 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
crosscheck backup;
restore archivelog from sequence 51595 until sequence 51610;
}

***************************************************************************

****************************How to check current schema ******************************************
select sys_context('userenv','current_schema') from dual;

alter session set current_schema=BO_MERCH_STRATEGIC_PLANNING_AN;

Grant select permission to the user 

SET HEADING OFF
SET PAGES 9999 LINES 400
SPOOL BRM01_TABLE_GRANTS.sql
SELECT 'GRANT SELECT ON ' || OWNER || '.' || TABLE_NAME || ' TO eiam01_readonly;' FROM DBA_TABLES WHERE OWNER IN ('BRM01') ORDER BY 1;
SPOOL OFF

************How to gather stats*************************************
exec dbms_stats.gather_schema_stats('ER_OWNER', method_opt => 'for all indexed columns size auto', degree => 4 ,cascade =>TRUE);

exec dbms_stats.gather_table_stats(ownname =>'TRIRIGA_OWNER', tabname =>'T_TRIPUNCHLISTTASK',estimate_percent =>20, method_opt => 'for all indexed columns size auto', cascade =>TRUE);

exec dbms_stats.gather_table_stats(ownname=>'ER_OWNER',tabname=>'SUM_EMP_HISTORY', method_opt => 'for all indexed columns size auto', degree => 8 ,cascade =>TRUE);

exec dbms_stats.gather_table_stats(ownname =>'PROFILEV5', tabname =>'DPS_USER',estimate_percent =>20, method_opt => 'for all indexed columns size auto', degree => 4 ,cascade =>TRUE);

analyze table DLPA_OWNER.INVOICE_HEADER compute statistics;

exec dbms_stats.gather_table_stats ('ER_OWNER','SUM_EMP_HISTORY',partname=>'FS4');

select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,NUM_ROWS,LAST_ANALYZED from dba_tab_partitions where PARTITION_NAME in ('FS_4','FS_5','FS_6','FS_7');

*********************************************************
********** How to find table size*******************

select segment_name,sum(bytes)/1024/1024 from dba_segments where owner='&&OWNER' and segment_name='&&TABLE_NAME' group by segment_name;

**Partition size****
SELECT partition_name, bytes/1024/1024 "MB"
FROM dba_segments
WHERE segment_name = <Table-name>
AND segment_type = 'TABLE PARTITION';


select table_name,round((blocks*8/1024),2) "size (Mb)" , 
                            round((num_rows*avg_row_len/1024/1024),2) "actual_data (Mb)",
                            (round((blocks*8/1024),2) - round((num_rows*avg_row_len/1024/1024),2)) "wasted_space (Mb)"
from dba_tables
where table_name in ('AQ_SYNC_BAK_040712','AQ_SYNC_BK_040712','BKUP_CFG_GLID_ACCTS_T','BKUP_CFG_INTU_GL_GLID_MAP_T') and (round((blocks*8/1024),2) > round((num_rows*avg_row_len/1024/1024),2))
order by table_name;

*********** How to find database size (db size) ********************

select
  ( select sum(bytes)/1024/1024/1024 data_size from dba_data_files ) +
  ( select nvl(sum(bytes),0)/1024/1024/1024 temp_size from dba_temp_files ) +
  ( select sum(bytes)/1024/1024/1024 redo_size from sys.v_$log ) +
  ( select sum(BLOCK_SIZE*FILE_SIZE_BLKS)/1024/1024/1024 controlfile_size from v$controlfile) "Size in GB"
from dual;
	
select round(sum(used.bytes) / 1024 / 1024 /1024 ) || 'GB' "Database Size",
round(free.p / 1024 / 1024 /1024) || 'GB' "Free space" from
(select bytes from v$datafile union all select bytes from v$tempfile
union all select bytes from v$log) used,
(select sum(bytes) as p from dba_free_space) free group by free.p;

*************DB Growth*****************

SET LINESIZE 400
SET PAGESIZE 9999
SET VERIFY   OFF
COLUMN month        FORMAT a7                   HEADING 'Month'
COLUMN growth       FORMAT 999,999,999,999,999  HEADING 'Growth (Bytes)'
BREAK ON report
COMPUTE SUM OF growth ON report
select 
to_char(creation_time, 'RRRR Month') "Month"
,round(sum(bytes)/1024/1024/1024) "Growth in GB" from sys.v_$datafile 
where creation_time > SYSDATE-360 group by to_char(creation_time, 'RRRR Month');


column REDOLOG_FILE_NAME format a55
SELECT  a.GROUP#, a.THREAD#, a.SEQUENCE#, a.ARCHIVED, a.STATUS, b.MEMBER AS REDOLOG_FILE_NAME, (a.BYTES/1024/1024) AS SIZE_MB FROM gv$log a JOIN gv$logfile b ON a.Group#=b.Group# ORDER BY a.GROUP#

select lf.group#,l_type.log_type as type, lf.member from v$logfile lf join (select group#,'ORL' as log_type from v$log union select group#,'SRL' as log_type from v$standby_log) l_type on lf.group#=l_type.group#
order by lf.group#;


ALTER DATABASE ADD STANDBY LOGFILE THREAD 1 GROUP 1 ('/u01/oradata/brmpdsp1/BRMPDSP1/onlinelog/redo01.log') SIZE 1024m, GROUP 2 ('/u01/oradata/brmpdsp1/BRMPDSP1/onlinelog/redo02.log') SIZE 1024m;

------Utilized database space-------
select sum(BYTES/1024/1024/1024) from dba_segments;
	
Ho to find segment size as per owner

select owner, segment_name, round(sum(bytes)/1024/1024/1024,1) "GB"
from dba_segments
where owner not like '%SYS%'
having round(sum(bytes)/1024/1024/1024,1) > 10.0
group by owner, segment_name
UNION ALL
select 'ORACLE', 'DATABASE', round(sum(bytes)/1024/1024/1024,1) "GB"
from dba_segments
order by 3 desc

******schema size*****
select owner, sum(bytes)/1024/1024/1024 "GB"
from dba_segments where owner='&OWNER'
group by owner;
**********************************************************************************
Schema refresh datapump
======================================================

set head off
set pages 0
set long 9999999
select  dbms_metadata.get_ddl('USER', 'DBSNMP') || '/' usercreate from DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','ERS_READONLY') FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','DGDEV') FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','DGDEV') FROM DUAL;


set head off
set pages 0
set long 9999999
select  dbms_metadata.get_ddl('TABLESPACE', 'TDHTRHDBS_TBS') || '/' usercreate from DUAL;


set head off
set pages 0
set long 9999999
select  dbms_metadata.get_ddl('TABLE', 'CASHP2') || '/' usercreate from DUAL;


verify log:

select OWNER, OBJECT_TYPE, count (*)  from DBA_OBJECTS where owner in ('FLEX_PROD') group by OWNER, OBJECT_TYPE ;
********************* Database backup**********************************************

*****************To see startdate, enddate*****************

col STATUS format a25
col hrs format 999.99
set pagesize 300
set linesize 300
select
SESSION_KEY, INPUT_TYPE, STATUS,
to_char(START_TIME,'mm/dd/yy hh24:mi') start_time,
to_char(END_TIME,'mm/dd/yy hh24:mi')   end_time,
elapsed_seconds/3600                   hrs
from V$RMAN_BACKUP_JOB_DETAILS 
WHERE INPUT_TYPE='DB FULL' 
order by session_key;

************** To see startdate, enddate with backup size**********

set line 10000 pages 10000
col OUTPUT_BYTES_DISPLAY for a20
col TIME_TAKEN_DISPLAY for a20
select session_key,input_type,status,
to_char(start_time,'yyyy-mm-dd hh24:mi') start_time,
to_char(end_time,'yyyy-mm-dd hh24:mi') end_time,
output_bytes_display,
time_taken_display
from v$rman_backup_job_details
where input_type='DB INCR'
order by session_key asc;


set line 10000 pages 10000
col OUTPUT_BYTES_DISPLAY for a20
col TIME_TAKEN_DISPLAY for a20
select session_key,input_type,status,
to_char(start_time,'yyyy-mm-dd hh24:mi') start_time,
to_char(end_time,'yyyy-mm-dd hh24:mi') end_time,
output_bytes_display,
time_taken_display
from v$rman_backup_job_details
where input_type='ARCHIVELOG'
order by session_key asc;

col STATUS format a15
Set lines 200 pages 200
col hrs format 999.99
select SESSION_KEY, INPUT_TYPE, STATUS, to_char(START_TIME,'mm/dd/yy hh24:mi') start_time, to_char(END_TIME,'mm/dd/yy hh24:mi') end_time, elapsed_seconds/3600 hrs from V$RMAN_BACKUP_JOB_DETAILS order by session_key;


Below query is to check whether backup is waiting for tape.

SELECT p.SPID, sw.EVENT, sw.SECONDS_IN_WAIT AS SEC_WAIT,sw.STATE, s.CLIENT_INFO
FROM V$SESSION_WAIT sw, V$SESSION s, V$PROCESS p
  WHERE sw.EVENT LIKE '%s%bt%'
AND s.SID=sw.SID
AND s.PADDR=p.ADDR
ORDER BY SEC_WAIT ASC;

+++++++++++FIND OUT THE RMAN BACKUP STATUS++++++++++++++++++++++++++++++


set pages 9999 lines 300
col status for a10
col object_type for a10

alter session set nls_date_format = 'DD-MM-YYYY HH24:MI:SS';

TEMP_PP_RITM1590705_1_ORDER

select SID,STATUS,START_TIME,END_TIME,OBJECT_TYPE,OUTPUT_DEVICE_TYPE
from v$rman_status order by START_TIME desc;

select SID,STATUS,START_TIME,END_TIME,OBJECT_TYPE,OUTPUT_DEVICE_TYPE
from v$rman_status  where status='RUNNING' order by START_TIME desc;

select SID,STATUS,START_TIME,END_TIME,OBJECT_TYPE,OUTPUT_DEVICE_TYPE
from v$rman_status  where status='COMPLETED' order by START_TIME desc;

To monitor job progress[RMAN]:
==============================

SELECT SID, SERIAL#, CONTEXT, SOFAR, TOTALWORK,ROUND (SOFAR/TOTALWORK*100, 2) "%_COMPLETE" FROM V$SESSION_LONGOPS 
WHERE OPNAME LIKE 'RMAN%'AND OPNAME NOT LIKE '%aggregate%' AND TOTALWORK != 0 AND SOFAR <> TOTALWORK; 

col status for a15
set linesize 200
col EVENT for a30
col program for a25
select a.sid,b.serial#, b.logon_time,b.status,a.state,a.seconds_in_wait,a.event,b.program,c.spid from v$session_wait a,v$session b, v$process c
where a.sid=b.sid and b.username = 'SYS' and b.PADDR = c.ADDR and b.program like '%rman%' order by 3;


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
************* Archive generation count ******************************
col "00" for a4
col "01" for a4
col "02" for a4
col "03" for a4
col "04" for a4
col "05" for a4
col "06" for a4
col "07" for a4
col "08" for a4
col "09" for a4
col "10" for a4
col "11" for a4
col "12" for a4
col "13" for a4
col "14" for a4
col "15" for a4
col "16" for a4
col "17" for a4
col "18" for a4
col "19" for a4
col "20" for a4
col "21" for a4
col "22" for a4
col "23" for a4
SELECT to_date(first_time) DAY,
to_char(sum(decode(to_char(first_time,'HH24'),'00',1,0)),'9999') "00",
to_char(sum(decode(to_char(first_time,'HH24'),'01',1,0)),'9999') "01",
to_char(sum(decode(to_char(first_time,'HH24'),'02',1,0)),'9999') "02",
to_char(sum(decode(to_char(first_time,'HH24'),'03',1,0)),'9999') "03",
to_char(sum(decode(to_char(first_time,'HH24'),'04',1,0)),'9999') "04",
to_char(sum(decode(to_char(first_time,'HH24'),'05',1,0)),'9999') "05",
to_char(sum(decode(to_char(first_time,'HH24'),'06',1,0)),'9999') "06",
to_char(sum(decode(to_char(first_time,'HH24'),'07',1,0)),'9999') "07",
to_char(sum(decode(to_char(first_time,'HH24'),'08',1,0)),'9999') "08",
to_char(sum(decode(to_char(first_time,'HH24'),'09',1,0)),'9999') "09",
to_char(sum(decode(to_char(first_time,'HH24'),'10',1,0)),'9999') "10",
to_char(sum(decode(to_char(first_time,'HH24'),'11',1,0)),'9999') "11",
to_char(sum(decode(to_char(first_time,'HH24'),'12',1,0)),'9999') "12",
to_char(sum(decode(to_char(first_time,'HH24'),'13',1,0)),'9999') "13",
to_char(sum(decode(to_char(first_time,'HH24'),'14',1,0)),'9999') "14",
to_char(sum(decode(to_char(first_time,'HH24'),'15',1,0)),'9999') "15",
to_char(sum(decode(to_char(first_time,'HH24'),'16',1,0)),'9999') "16",
to_char(sum(decode(to_char(first_time,'HH24'),'17',1,0)),'9999') "17",
to_char(sum(decode(to_char(first_time,'HH24'),'18',1,0)),'9999') "18",
to_char(sum(decode(to_char(first_time,'HH24'),'19',1,0)),'9999') "19",
to_char(sum(decode(to_char(first_time,'HH24'),'20',1,0)),'9999') "20",
to_char(sum(decode(to_char(first_time,'HH24'),'21',1,0)),'9999') "21",
to_char(sum(decode(to_char(first_time,'HH24'),'22',1,0)),'9999') "22",
to_char(sum(decode(to_char(first_time,'HH24'),'23',1,0)),'9999') "23"
from
v$log_history
where to_date(first_time) > sysdate -5
GROUP by
to_char(first_time,'YYYY-MON-DD'), to_date(first_time)
order by to_date(first_time)
/

**** Hourly basis *****

set pages 1000
select trunc(COMPLETION_TIME,'HH') Hour,thread# , round(sum(BLOCKS*BLOCK_SIZE)/1073741824) GB,count(*) Archives from v$archived_log
group by trunc(COMPLETION_TIME,'HH'),thread#  order by 1 ;
***************************
set pages 1000
set lines 200
select trunc(COMPLETION_TIME,'DD') Day, thread#, round(sum(BLOCKS*BLOCK_SIZE)/1048576) MB,count(*) Archives_Generated from v$archived_log
group by trunc(COMPLETION_TIME,'DD'),thread# order by 1;

**************Redo log scripts*************************
column REDOLOG_FILE_NAME format a55
SELECT  a.GROUP#, a.THREAD#, a.SEQUENCE#, a.ARCHIVED, a.STATUS, b.MEMBER AS REDOLOG_FILE_NAME, (a.BYTES/1024/1024) AS SIZE_MB FROM gv$log a JOIN gv$logfile b ON a.Group#=b.Group# ORDER BY a.GROUP#;

column REDOLOG_FILE_NAME format a55
select lf.group#,l_type.log_type as type, lf.member from v$logfile lf join (select group#,'ORL' as log_type from v$log union select group#,'SRL' as log_type from v$standby_log) l_type on lf.group#=l_type.group# order by lf.group#;

***********************************************************************
************* Flashback database to restore point*************

shutdown immediate;

startup mount;

flashback database to restore point <restorepoint_name>;

alter database open resetlogs;

************************************************************
************** restore point query **************

select * from v$restore_point;
drop restore point <restorepoint name>;

CREATE RESTORE POINT <restore point name> GUARANTEE FLASHBACK DATABASE;

*************** db_recovery_file_dest **********************

Select Substr(Name,1,40) name,
Space_Limit/1024/1024/1024 Space_Limit,
Space_Used/1024/1024/1024 Spce_Used,
Space_Reclaimable/1024/1024/1024 Space_Reclaimable,
Number_Of_Files Number_files
from V$RECOVERY_FILE_DEST;

SELECT Name ,
   ceil( space_limit / 1024 / 1024) SIZE_M,
   ceil( space_used  / 1024 / 1024) USED_M,
   ceil( space_reclaimable  / 1024 / 1024) RECLAIMABLE_M,
   decode( nvl( space_used, 0), 0, 0 , ceil ( ( ( space_used - space_reclaimable ) / space_limit) * 100) ) PCT_USED
FROM v$recovery_file_dest
ORDER BY name

SELECT GROUP_NUMBER,NAME,TOTAL_MB/1024,FREE_MB/1024,USABLE_FILE_MB/1024 FROM V$ASM_DISKGROUP;
  
  ADMINISTER KEY MANAGEMENT SET KEYSTORE  open identified by "gHe7UAJictqpz1Yj";

keystore altered.

SQL> alter database recover managed standby database using current logfile disconnect;
  
  
**************************** dataguard related *************************
edit configuration set property CommunicationTimeout=300;

PRIAMRY:

select max(sequence#),thread# from gv$archived_log group by thread#;

SQL> SELECT THREAD#, LOW_SEQUENCE#, HIGH_SEQUENCE# FROM V$ARCHIVE_GAP;
no rows selected

Jay 
********

set linesize 200
column dest_name format a30
column destination format a30
column error format a20 wrap
select DEST_ID,DEST_NAME,STATUS,DESTINATION,DELAY_MINS,NET_TIMEOUT,DB_UNIQUE_NAME,ERROR from v$archive_dest;

************ See the difference of redo applied and recieved*****************
CONFIGURE ARCHIVELOG DELETION POLICY TO NONE; # default
 sh tail -20f ggserr.log

Standby:

SELECT ARCH.THREAD# "Thread", ARCH.SEQUENCE# "Last Sequence Received", APPL.SEQUENCE# "Last Sequence Applied", (ARCH.SEQUENCE# - APPL.SEQUENCE#) "Difference" FROM
(SELECT THREAD# ,SEQUENCE# FROM V$ARCHIVED_LOG WHERE (THREAD#,FIRST_TIME ) IN (SELECT THREAD#,MAX(FIRST_TIME) FROM V$ARCHIVED_LOG GROUP BY THREAD#)) ARCH,
(SELECT THREAD# ,SEQUENCE# FROM V$LOG_HISTORY WHERE (THREAD#,FIRST_TIME ) IN (SELECT THREAD#,MAX(FIRST_TIME) FROM V$LOG_HISTORY GROUP BY THREAD#)) APPL
WHERE ARCH.THREAD# = APPL.THREAD# ORDER BY 1;


select LOG_ARCHIVED-LOG_APPLIED "LOG_GAP" from
(SELECT MAX(SEQUENCE#) LOG_ARCHIVED
FROM V$ARCHIVED_LOG WHERE DEST_ID=1 AND ARCHIVED='YES'),
(SELECT MAX(SEQUENCE#) LOG_APPLIED
FROM V$ARCHIVED_LOG WHERE DEST_ID=2 AND APPLIED='YES');

********MRP process status*********

SELECT PROCESS, STATUS, THREAD#, SEQUENCE#, BLOCK#, BLOCKS, DELAY_MINS from v$managed_standby;

SELECT PROCESS, STATUS, THREAD#, SEQUENCE#, BLOCK#, BLOCKS, DELAY_MINS from v$managed_standby where PROCESS like 'MRP%';

select message from v$dataguard_status;

col dest_name format a20
select dest_name,error from v$archive_dest;

To copy missed archive log and register to standby

alter database register logfile '/a01/oradata/brmprfs1/arch/2_1443_1004667845.dbf';

alter system set log_archive_dest_2='SERVICE=adgsys LGWR ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=pimsysdb1' scope= both sid='*';

*****************************************************************************************
DBSNMP 
password: pack3rsl0ststeelers

select
 b.group#, a.archived, a.status, b.status, b.member 
from
 v$log a, v$logfile b
where a.group#=b.group#
order by 1,2;

************************* RMAN*******************

delete noprompt force archivelog all completed before 'sysdate-1/4';

connect target /

crosscheck archivelog all;
crosscheck archivelog sequence 13 thread 2;

delete expired archivelog all;
delete expired datafilecopy all;

RMAN> delete noprompt archivelog from sequence 102116 until sequence 1775 ; 

delete noprompt archivelog until sequence 939240 thread 1;
delete noprompt archivelog until sequence 65345 thread 2;
delete force archivelog until sequence 10352 thread 1;

delete force archivelog until sequence 32165 thread 2;


delete archivelog until time 'sysdate-1';
delete noprompt archivelog until time 'sysdate-30';

delete force archivelog all backed up 1 times to sbt;
delete noprompt archivelog all backed up 1 times to sbt;

show all;
list backup;
report obsolete;
delete obsolete;
delete backup tag='BACKUP_PPPH2_00677_012015083128';

list backup summary completed before "sysdate -15";
delete noprompt backup completed before "sysdate -1";
list backup summary completed before "sysdate -8";

Standby:
CONFIGURE ARCHIVELOG DELETION POLICY TO BACKED UP 1 TIMES TO 'DISK' APPLIED ON ALL STANDBY;
CONFIGURE ARCHIVELOG DELETION POLICY TO APPLIED ON STANDBY;

Primary:
CONFIGURE ARCHIVELOG DELETION POLICY TO BACKED UP 1 TIMES TO 'SBT_TAPE' SHIPPED TO ALL STANDBY;


[oracle@xxxxxxxxxxx ~]$ cat crosscheck_and_delete_expired.rman
run
{
crosscheck backup;
crosscheck copy;
delete expired backup;
}

[oracle@xxxxxxxxxxx ~]$ mv OEMT1_crosscheck_and_delete_expired.log OEMT1_crosscheck_and_delete_expired.log_old
[oracle@xxxxxxxxxxx ~]$ . oraenv
ORACLE_SID = [xxxx] ? xxxxx
The Oracle base remains unchanged with value /u01/app/oracle
[oracle@xxxxxxxxxxx ~]$ rman target / cmdfile=crosscheck_and_delete_expired.rman log=crosscheck_and_delete_expired.log &


******How to restore archive logs*****
run
{
execute script allocate_archive_channel;
set archivelog destination to '/usr/local/oracle/archive/a';
restore archivelog from logseq 379924 until logseq 379930 thread 1;
execute script release_archive_channel;
}

*****************Pre-prod restore in intuit***********

run {
allocate channel dev1 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
allocate channel dev2 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
allocate channel dev3 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
allocate channel dev4 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
crosscheck backup;
restore archivelog from sequence 55120 until sequence 55421;
}

*************************************************************************
************* ADD candidate disk in disk group***************************

SELECT GROUP_NUMBER,NAME,TOTAL_MB/1024,FREE_MB/1024,USABLE_FILE_MB/1024 FROM V$ASM_DISKGROUP;
select GROUP_NUMBER,NAME,TOTAL_MB/1024 "Total_GB" ,FREE_MB/1024 "Free_GB",FREE_MB/TOTAL_MB*100 "% Free" from v$asm_diskgroup;

select d.group_number,g.NAME,d.header_status, count(*) disk_count,sum(os_mb/1024) total_gb from v$asm_disk d,V$ASM_DISKGROUP g where d.GROUP_NUMBER=g.GROUP_NUMBER group by d.group_number,g.NAME,d.header_status;

select path,os_mb/1024,header_Status from v$asm_Disk where header_Status!='MEMBER';

select group_number, path, header_status,os_mb/1024 from v$asm_disk order by 1;

alter diskgroup DATA01 add disk '/dev/oradisk/ASM/new_asm_vol28' rebalance power 4;

alter diskgroup RECOVER01 drop disk RECOVER01_0002;

alter diskgroup DATA01 rebalance power 10;
select * from v$asm_operation;

SELECT group_number, operation, state, power, est_minutes FROM v$asm_operation;

*********IMBALANCE******

SELECT g.name "Diskgroup",
    100*(max((d.total_mb-d.free_mb)/d.total_mb)-min((d.total_mb-d.free_mb)/d.total_mb))/max((d.total_mb-d.free_mb)/d.total_mb) "Imbalance",
    100*(max(d.total_mb)-min(d.total_mb))/max(d.total_mb) "Variance",
    100*(min(d.free_mb/d.total_mb)) "MinFree",
    count(*) "DiskCnt",
    g.type "Type"
    FROM v$asm_disk d, v$asm_diskgroup g
    WHERE d.group_number = g.group_number and
    d.group_number <> 0 and
    d.state = 'NORMAL' and
    d.mount_status = 'CACHED'
    GROUP BY g.name, g.type;

*******************************************************************
*********** How to remove running trace files***************

select pid, program from v$process where program like '%ora%';

oradebug setorapid 16

!mv /usr/local/oracle/log/diag/asm/+asm/+ASM2/trace/+ASM2_rbal_28646.trc /usr/local/oracle/log/diag/asm/+asm/+ASM2/trace/+ASM2_rbal_28646.trc_old
!mv /usr/local/oracle/log/diag/asm/+asm/+ASM2/trace/+ASM2_rbal_28646.trm /usr/local/oracle/log/diag/asm/+asm/+ASM2/trace/+ASM2_rbal_28646.trm_old

oradebug close_trace

***********************************************************************
************** Flush shared pool**************************************

SELECT POOL,NAME, ROUND(BYTES/1024/1024,2) FREE_MB 
FROM V$SGASTAT 
WHERE POOL='shared pool' AND NAME='free memory' ORDER BY BYTES DESC;

alter system flush shared_pool;

col value for 999,999,999,999 heading “Shared Pool Size”
col bytes for 999,999,999,999 heading “Free Bytes”
select to_number(v$parameter.value) value, v$sgastat.bytes,
(v$sgastat.bytes/v$parameter.value)*100 "Percent Free"
from v$sgastat, v$parameter
where v$sgastat.name = 'free memory'
and v$parameter.name = 'shared_pool_size';

************************************************************************
********************** RMAN COLD BACKUP ************************
===========

shutdown immediate

startup mount

BACKUP DATABASE FORMAT "/usr/local/oracle/exports/devplx01_coldbackup_%U";  

Archives deletaton based on time.
**********************************


select sysdate - interval '3' hour from dual

DELETE archivelog until time "to_date('21-09-2018:11:11:01','DD-MM-YYYY:hh24:mi:ss')";

************************ CRSCTL and SRVCTL commands **********************
crsctl check has
crsctl stop has
crsctl start has
crsctl status resource -t

** How to start OCSSD manually ************
./crsctl start res ora.cssd -init -env "CSSD_MODE=-X"


crd_stat
srvctl status scan_listener

$ srvctl status scan_listener -i 3
SCAN Listener LISTENER_SCAN3 is enabled
SCAN listener LISTENER_SCAN3 is running on node uecdb01

srvctl relocate scan_LISTENER -i 3 -n uecdb03
srvctl relocate scan_LISTENER -i 1 -n uecdb01

srvctl status service -d <database name>         PRDCDI

srvctl status instance -d <database name> -i <instance name>

Check for prefered node
srvctl config service -d <db name> -s <service name>

crsctl status resource -t


If we don't know database name but know service name 
crsctl status resource -t  | grep -i <service name>


srvctl -h|grep service

crs_stat | awk -F= '/NAME=/{n=$2}/TYPE=/{t=$2}/TARGET=/{g=$2}/STATE=/{s=$2; printf("%-75s%-18s%-15s%-30s\n", n,t,g,s)}'



******* How to relocate services and bring down database, ASM and clusterware (DB version 11.1...) ********

srvctl status service -d PRDREF
srvctl relocate service -d PRDREF -s prdref_batch -i prdref2 -t prdref1 -f
srvctl relocate service -d PRDREF -s prdrefloy -i prdref2 -t prdref1 -f
srvctl status service -d PRDREF

srvctl status database -d PRDREF
srvctl status instance -d PRDREF -i prdref2
srvctl stop instance -d PRDREF -i prdref2

srvctl status asm -n pcdidb05
srvctl stop asm -n pcdidb05

srvctl status nodeapps -n pcdidb05
srvctl stop nodeapps -n pcdidb05

Stop the listener and agent from the node(pcdidb05):- As root user
cd /usr/local/crs/11.1.0/bin/
./crsctl check crs
./crsctl stop crs
****************** Checking previleges ****************************

SQL> select GRANTEE,TABLE_NAME,OWNER,PRIVILEGE from dba_tab_privs where TABLE_NAME='POWER_WORK_ITEM' and GRANTEE='PWR_PERFTEST_APP';

GRANTEE                        TABLE_NAME                     OWNER                          PRIVILEGE
------------------------------ ------------------------------ ------------------------------ ----------------------------------------
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_SYSTEST_OWNER              DELETE
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_SYSTEST_OWNER              SELECT
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_SYSTEST_OWNER              UPDATE
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_PERFTEST_OWNER             DELETE
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_PERFTEST_OWNER             INSERT
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_PERFTEST_OWNER             SELECT
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_PERFTEST_OWNER             UPDATE

SQL> select * from dba_synonyms where table_name='POWER_WORK_ITEM' and owner='PWR_PERFTEST_APP';

OWNER              SYNONYM_NAME    TABLE_OWNER          TABLE_NAME                     DB_LINK
------------------ --------------- -------------------- ------------------------------ ------------------------------
PWR_PERFTEST_APP   POWER_WORK_ITEM PWR_SYSTEST_OWNER    POWER_WORK_ITEM



********************* REFRESH POWER database *******************
Schema credentials: /usr/local/oracle/etc/oracle_schema.pwd

SQL> show user
USER is "PWR_SNAP"
SQL> exec dbms_mview.refresh('PWR_SNAP.TBF0_THRD_PTY_PLN_PARAM_SNAP','C');

PL/SQL procedure successfully completed.

SQL> exec dbms_mview.refresh('PWR_SNAP.TBF0_THRD_PTY_PLN_PARAM_SNAP','F');

PL/SQL procedure successfully completed.

Check the mview status.
column last_refresh_type format a25
column owner format a20
column mview_name format a35
select owner, mview_name, last_refresh_type, last_refresh_date
from dba_mviews order by last_refresh_date;
 
exec dbms_mview.refresh( 'ARESLOG_HRLY', 'C' );
exec dbms_mview.refresh( 'ARACSLOG_HRLY', 'C' );
exec dbms_mview.refresh( 'ARESLOG_HRLY', 'C' );

*****ICPLUS********
Password location: /usr/local/oracle/etc/license_icplus0_pw

To check job name:

col JOB_ACTION form a30
col SCHEDULE_NAME form a20
COL OWNER FORM A10
select
-- owner,
owner, job_name, enabled, schedule_name, job_type, job_action,
-- RUN_COUNT run_cnt,
-- FAILURE_COUNT fail_cnt,
to_char(LAST_START_DATE,'mm-dd-yy hh24:mi:ss') LAST_START_DATE,
to_char(NEXT_RUN_DATE,'mm-dd-yy hh24:mi:ss') NEXT_RUN_DATE
from DBA_SCHEDULER_JOBS
where job_name like 'ARACCTHOLDERAUTH%'
      and owner not in ('SYS','SYSTEM');

OWNER      JOB_NAME                       ENABL SCHEDULE_NAME        JOB_TYPE         JOB_ACTION                     LAST_START_DATE   NEXT_RUN_DATE
---------- ------------------------------ ----- -------------------- ---------------- ------------------------------ ----------------- -----------------
ICPLUS_0   MV_JOB_NCPDP_DATA_FMT          TRUE  EVERY_1_HOUR         STORED_PROCEDURE MV_PROC_NCPDP_DATA_FMT         11-10-14 09:14:38 11-10-14 10:14:37
ICPLUS_0   MV_JOB_PBR_THRD_PTY            TRUE  EVERY_6_HOUR         STORED_PROCEDURE MV_PROC_PBR_THRD_PTY           11-10-14 05:14:37 11-10-14 11:14:37
ICPLUS_0   MV_JOB_PLAN_DRUG_COVERAGE      TRUE  EVERY_6_HOUR         STORED_PROCEDURE MV_PROC_PLAN_DRUG_COVERAGE     11-10-14 05:14:37 11-10-14 11:14:37
ICPLUS_0   MV_JOB_PRESCRIBER_NTIS         TRUE  EVERY_6_HOUR         STORED_PROCEDURE MV_PROC_PRESCRIBER_NTIS        11-10-14 05:14:37 11-10-14 11:14:37
ICPLUS_0   MV_JOB_PRESCRIBER              TRUE  EVERY_30_SECOND      STORED_PROCEDURE MV_PROC_PRESCRIBER             11-10-14 09:22:06 11-10-14 09:11:54
ICPLUS_0   MV_JOB_PWR_STORE               TRUE  EVERY_15_MINUTE      STORED_PROCEDURE MV_PROC_PWR_STORE              11-10-14 09:14:37 11-10-14 09:29:37
ICPLUS_0   MV_JOB_REH_TPR_CD_MAPPING      TRUE  EVERY_1_HOUR         STORED_PROCEDURE MV_PROC_REH_TPR_CD_MAPPING     11-10-14 09:14:37 11-10-14 10:14:37
ICPLUS_0   MV_JOB_REH_TPR_ROUTING         TRUE  EVERY_1_HOUR         STORED_PROCEDURE MV_PROC_REH_TPR_ROUTING        11-10-14 09:14:37 11-10-14 10:14:37
ICPLUS_0   MV_JOB_STATE_LABEL_RQMT        TRUE  EVERY_1_HOUR         STORED_PROCEDURE MV_PROC_STATE_LABEL_RQMT       11-10-14 09:14:37 11-10-14 10:14:37
ICPLUS_0   MV_JOB_RXC_PLAN                TRUE  EVERY_8_HOUR         STORED_PROCEDURE MV_PROC_RXC_PLAN               11-10-14 09:14:37 11-10-14 17:14:37
ICPLUS_0   MV_JOB_CODE_DTL                TRUE  EVERY_6_HOUR         STORED_PROCEDURE MV_PROC_CODE_DTL               11-10-14 05:14:37 11-10-14 11:14:37


To check DDL from proc (job action)
	  
select text from dba_source where OWNER='SYS' and NAME='MAINTENANCE_WINDOW_GROUP' /*Job_Action from dba_scheduler_jobs*/ ;

select dbms_metadata.get_ddl('INDEX','UPDATE_BILLING_PROFILE','BILLING') from dual; 

**** Check for snap and use the same in refresh*******

SQL> conn ICPLUS_0/idah0p0tat0
Connected.

exec dbms_mview.refresh('ICPLUS_0.TBF0_PRESCRIBER_NTIS_SNAP','C');

exec dbms_mview.refresh('ICPLUS_0.TBF0_PRESCRIBER_NTIS_SNAP','F');


SELECT owner, mview_name, last_refresh_date FROM dba_mviews;


CREATE MATERIALIZED VIEW LOG ON "SECS7"."ARACSLOG" PCTFREE 10 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 
MAXEXTENTS 2147483645 PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) TABLESPACE "S7_MV_DATA"
WITH ROWID ( "BANKID", "PAREQTIME", "PARESSTATUS", "RANGEID", "TXTYPE" ) INCLUDING NEW VALUES;



select owner, mview_name, last_refresh_type, last_refresh_date from dba_mviews order by owner ;


Matirilized views

col owner for a10
col mview_name for a30
col last_refresh_type for a20
col last_refresh_date for a40
select owner, mview_name, last_refresh_type, last_refresh_date from dba_mviews order by last_refresh_date ; 
 


**************** USER management **************************************

select OWNER,TRIGGER_NAME,STATUS from dba_triggers where TRIGGER_NAME like '%DROP%';

ALTER TRIGGER TR_USER_NODROP DISABLE;

ALTER TRIGGER TR_USER_NODROP ENABLE;



*********** How to open a database is archive log mode **************

SQL> select name,open_mode,log_mode from v$database;

NAME      OPEN_MODE            LOG_MODE
--------- -------------------- ------------
DEVSRX01  READ WRITE           NOARCHIVELOG

SQL> select DEST_NAME,STATUS,DESTINATION from V$ARCHIVE_DEST;

DEST_NAME                      STATUS    DESTINATION
------------------------------ --------- ------------------------------------------------------------
LOG_ARCHIVE_DEST_1             VALID     /usr/local/oracle/product/11.2.0/dbhome_1/dbs/arch
LOG_ARCHIVE_DEST_2             INACTIVE
LOG_ARCHIVE_DEST_3             INACTIVE
LOG_ARCHIVE_DEST_4             INACTIVE
LOG_ARCHIVE_DEST_5             INACTIVE

SQL> show parameter backup_tape_io_slaves

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
backup_tape_io_slaves                boolean     FALSE


alter system set LOG_ARCHIVE_DEST_1='LOCATION=/usr/local/oracle/archive/c' scope=both;

Shutdown immediate;

startup mount;

alter database archivelog;

alter database open;

********************************************************************

ORA-04021: timeout occurred while waiting to lock object

Basically, whilst someone or something else (a scheduled job perhaps?) is executing the package, then you won’t be able to perform the recompile.  To get around this, you need to identify the locking session and kill it.

BREAK ON sid ON lock_id1 ON kill_sid

COL sid            FOR 999999
COL lock_type      FOR A38
COL mode_held      FOR A12
COL mode_requested FOR A12
COL lock_id1       FOR A20
COL lock_id2       FOR A20
COL kill_sid       FOR A50

SELECT s.sid,
       l.lock_type,
       l.mode_held,
       l.mode_requested,
       l.lock_id1,
       'alter system kill session '''|| s.sid|| ','|| s.serial#|| ''' immediate;' kill_sid
FROM   dba_lock_internal l,
       v$session s
WHERE  s.sid = l.session_id
AND    UPPER(l.lock_id1) LIKE '%&package_name%'
AND    l.lock_type = 'Body Definition Lock'
/

    SID LOCK_TYPE                              MODE_HELD    MODE_REQUEST LOCK_ID1             KILL_SID
------- -------------------------------------- ------------ ------------ -------------------- --------------------------------------------------
    218 Body Definition Lock                   Null         None         USER2.TEST_PACKAGE   alter system kill session '218,12455' immediate;
	
	
NOTE: If your dba_lock_internal view doesn’t exist, you can create this by running: $ORACLE_HOME/rdbms/admin/catblock.sql

Check out what the offending session is doing:

BREAK ON sid ON username ON osuser ON os_pid ON program

SELECT s.sid,
       NVL(s.username, 'ORACLE PROC') username,
       s.osuser,
       p.spid os_pid,
       s.program,
       t.sql_text
FROM   v$session s,
       v$sqltext t,
       v$process p
WHERE  s.sql_hash_value = t.hash_value
AND    s.paddr = p.addr
AND    s.sid = &session_id
AND    t.piece = 0 -- optional to list just the first line
ORDER BY s.sid, t.hash_value, t.piece
/

SID   USERNAME     OSUSER       OS_PID     PROGRAM               SQL_TEXT
----- ------------ ------------ ---------- --------------------- --------------------------------------------------------------
218   USER2        oracle       8023       oracle@linux01 (J001) DECLARE job BINARY_INTEGER := :job; next_date DATE := :mydate;

********************* Drop database **********************

1.Shutdown immediate.
2.Startup mount exclusive restrict.
3.drop database

Drop database command should remove databases files,controlfiles,alert log


******** How to export statistics of a locked table ***********

Step 1: Check for locked statistics
select owner,table_name,stattype_locked from dba_tab_statistics where owner=<owner name> and stattype_locked='ALL' order by 1;

Step 2: Unlock table stats
exec dbms_stats.unlock_table_stats('OWNER','TABLE_NAME');

Step 3: Create stattab ****** table where we export stats******
exec dbms_stats.create_stat_table(ownname => 'OWNER_NAME', stattab =>'STATTAB_NAME', tblspace => 'TBS_NAME');

Step 4: Export table stats to the stattab
exec dbms_stats.export_table_stats(ownname=>'OWNER_NAME', tabname => 'TABLE_NAME', stattab =>'STATTAB_NAME',cascade=>true);

Step 5: Lock table stats
exec dbms_stats.lock_table_stats('OWNER_NAME','TABLE_NAME');

Step 1: Verify locked statistics
select owner,table_name,stattype_locked from dba_tab_statistics where owner=<owner name> and stattype_locked='ALL' order by 1;

****************************************************************

For Hanganalyze: 

sqlplus '/ as sysdba' 
oradebug setmypid 
oradebug unlimit 
oradebug hanganalyze 3 
-- Wait one minute before getting the second hanganalyze 
oradebug hanganalyze 3 
-- Wait one minute before getting the third hanganalyze 
oradebug hanganalyze 3 
oradebug tracefile_name 
exit 

For Systemstate dump: 

sqlplus '/ as sysdba' 
oradebug setmypid 
oradebug unlimit 
oradebug dump systemstate 266 
oradebug dump systemstate 266 
oradebug tracefile_name 
exit 

*****************************************************************
*****SQL tuning adviser ********

set serveroutput on
declare
  l_sql_tune_task_id  varchar2(100);
begin
  l_sql_tune_task_id := dbms_sqltune.create_tuning_task (
                          sql_id      => '6zmr1syjpr42t',
                          scope       => dbms_sqltune.scope_comprehensive,
                          time_limit  => 60,
                          task_name   => 'test_2',
                          description => 'tuning task for statement your_sql_id.');
  dbms_output.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);
end;
/


exec dbms_sqltune.execute_tuning_task(task_name => 'test_2');

-- displaying the recommendations
set long 100000;
set longchunksize 1000
set pagesize 10000
set linesize 100
select dbms_sqltune.report_tuning_task('test_2') as recommendations from dual;​

*************************************
*** SQL monitoring report ***********

SET LONG 1000000
SET LONGCHUNKSIZE 1000000
SET LINESIZE 1000
SET PAGESIZE 0
SET TRIM ON
SET TRIMSPOOL ON
SET ECHO OFF
SET FEEDBACK OFF

SPOOL /tmp/sql_monitor_8pyztx5g69btg.html

SELECT DBMS_SQLTUNE.report_sql_monitor(
  sql_id => '8pyztx5g69btg',
  type => 'HTML',
  report_level => 'ALL') AS report
FROM dual;

spool off

*****************************

**************IDRMS**************

set long 100000
set head off
set echo off
set pagesize 0
set verify off
SELECT dbms_metadata.get_ddl('USER','&&uname') FROM dual;


********** How to see Hidden parameters ***********

SET PAUSE ON
SET PAUSE 'Press Return to Continue'
SET PAGESIZE 60
SET LINESIZE 300
COLUMN ksppinm FORMAT A50
COLUMN ksppstvl FORMAT A50
SELECT
  ksppinm,
  ksppstvl
FROM
  x$ksppi a,
  x$ksppsv b
WHERE
  a.indx=b.indx 
AND
  substr(ksppinm,1,1) = '_'
ORDER BY ksppinm
/


************* EXPDP IMPDP Export Import****************

SQL> create directory EXPDP as '/u01/oraogg/oexprf1/expdp/';  

Directory created. 

SQL> grant all on directory EXPDP to system; 

Grant succeeded.

vi expdp.par

userid='/as sysdba' 
directory=DMPDIR 
dumpfile=casoltp_prod_13sep19_%U.dmp 
logfile=casoltp_prod_13sep19_.log 
compression=all
full=y 
parallel=4 

schemas=brm104_01
tables=<schema name>.<table name>

USERID='/ as sysdba'
TABLES=LPD_DASHBD_OWNER.STG_CV_TXN_RTRN_DTL
REMAP_SCHEMA=LPD_DASHBD_OWNER:LPD_AB_TEST
directory=REFRESH_DIR
DUMPFILE=expdp_tables.dmp
LOGFILE=impdp_tables_test1.log

select property_value from database_properties where property_name like '%DEFAULT_TEMP_TABLESPACE%';

userid='/ as sysdba'
DIRECTORY=DMPDIR
DUMPFILE=BRM101_FACTOPS-3592.dmp
logfile=BRM101_FACTOPS-3592.dmp.log
remap_tablepace=PINX00:PINX00
REMAP_TABLESPACE=PIN00:PIN00
REMAP_SCHEMA=BRM101:BRM101
FILESIZE=20G
parallel=4
schemas=<schema1>,<schema2>
CONTENT=DATA_ONLY

userid='/ as sysdba'
Directory=EXPDP
DUMPFILE=expdp_Schema_FACTOPS-4411_%U.dmp
logfile=expdp_FACTOPS-4411.log
parallel=4
schemas=OEAPP,OEOWNER
compression=all


nohup expdp "'/ as sysdba '" directory=DBPUMP dumpfile=FACTOPS-4035_%U.dmp logfile=FACTOPS-4035.log parallel=5 TABLES=BRM01.JOURNAL_T FLASHBACK_SCN=12904691149691 filesize=200m compression=all &
 
+++++++++ % completion of export expdb or import impdp +++++++++++++
set lines 200 pages 2000
col STATE format a12
col OWNER_NAME format a14
col JOB_MODE format a13
select sid, serial#, sofar, totalwork,
dp.owner_name, dp.state, dp.job_mode
from gv$session_longops sl, gv$datapump_job dp
where sl.opname = dp.job_name and sofar != totalwork;

======================================================
Schema refresh datapump
======================================================`

set head off
set pages 0
set long 9999999
select  dbms_metadata.get_ddl('USER', 'BROM01') || '/' usercreate from DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','ACCOUNT') FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','ACCOUNT') FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','ACCOUNT') FROM DUAL;


set head off
set pages 0
set long 9999999
select  dbms_metadata.get_ddl('TABLESPACE', 'TDHTRHDBS_TBS') || '/' usercreate from DUAL;


set head off
set pages 0
set long 9999999
select  dbms_metadata.get_ddl('TYPE', 'BRM10_101') || '/' usercreate from DUAL;


set heading off;
set echo off;
Set pages 999;
set long 90000;
 
spool ddl_list.sql
 
select dbms_metadata.get_ddl('TABLE','DEPT','SCOTT') from dual;

verify log:

select OWNER, OBJECT_TYPE, count (*)  from DBA_OBJECTS where owner in ('BRM_EBPI_RO') group by OWNER, OBJECT_TYPE ;
 
+++++++ no. of rows processed in import impdp ++++++++++++
select substr(sql_text,instr(sql_text,'into "'),30) table_name,
rows_processed, round((sysdate-to_date(first_load_time,'yyyy-mm-dd hh24:mi:ss'))*24*60,1) minutes,
trunc(rows_processed/((sysdate-to_date(first_load_time,'yyyy-mm-dd hh24:mi:ss'))*24*60)) rows_per_minute
from sys.v_$sqlarea
where sql_text like 'insert %into "%' and command_type = 2 and open_versions > 0;

********* To check table lock ***********
SELECT A.SID, A.SERIAL#,A.USERNAME
FROM gV$SESSION A, gV$LOCKED_OBJECT B, DBA_OBJECTS C 
WHERE B.OBJECT_ID = C.OBJECT_ID 
AND A.SID = B.SESSION_ID
AND OBJECT_NAME='&TABLENAME';
INVOICE_HEADER


set linesize 300
col U_NAME format a15
col OBJ_OWNER format a15
col OBJECT_NAME format a20
col OSUSER format a10
col MODE_HELD format a20
SELECT username U_NAME, owner OBJ_OWNER,
object_name, object_type, s.osuser,
DECODE(l.block,
  0, 'Not Blocking',
  1, 'Blocking',
'Global') STATUS,
DECODE(v.locked_mode,
    0, 'None',
    1, 'Null',
    2, 'Row-S (SS)',
    3, 'Row-X (SX)',
   4, 'Share',
   5, 'S/Row-X (SSX)',
    6, 'Exclusive', TO_CHAR(lmode)
 ) MODE_HELD
FROM gv$locked_object v, dba_objects d,
gv$lock l, gv$session s
WHERE owner=('SECS5')
AND OBJECT_NAME='ARACCTHOLDERAUTH'
AND v.object_id = d.object_id
AND (v.object_id = l.id1)
AND v.session_id = s.sid
ORDER BY username, session_id;

**************************************
******* Cursor related queries **********

SELECT s.sid,oc.user_name,oc.SQL_ID,oc.HASH_VALUE,s.MACHINE,s.PROGRAM,s.LOGON_TIME,s.STATE,s.status
 FROM v$open_cursor oc, v$session s
 WHERE OC.sid = S.sid and CURSOR_TYPE='OPEN';
 
select count(*) current_open_cursor from v$open_cursor where CURSOR_TYPE='OPEN';

*********************************
ORA-8104
http://oracle-info.com/2013/01/16/ora-8104-this-index-object-xxxx-is-being-online-built-or-rebuilt/

select owner, constraint_name,table_name,index_owner,index_name from dba_constraints where (index_owner,index_name) in (select owner,index_name from dba_indexes where TABLE_NAME='ESB_ACTIVITY' and owner='OBOFM');


alter replicat R4OTBAIA extseqno 1219 extrba 314321888. 
************Explain plan****************

Method 1: If we know SQL_ID

select plan_table_output from table(dbms_xplan.display_cursor('4cbd3rqn2du24'));
select * from TABLE(dbms_xplan.display_awr('4cbd3rqn2du24'));

Method 2: If we know SQL

explain plan for SELECT RULEMNEMONIC, max(DESCRNAME) DESCRNAME FROM ARRFSYSRULEEXECCONFIG WHERE RULEMNEMONIC != 'SCORE' AND EXECVERSION IN ( SELECT DATAVERSION FROM ARRFSYSORGCONFIG WHERE CONFIGTYPE='EXEC'
AND ORGNAME in ('HSBCCREDIT','HSBCMCDEBIT','HSBCFDCREDIT','HSBCFDDEBIT','HSBCDEBIT','HSBCDEBITPREMIER','HSBCBUSINESSCREDIT','HSBCBUSINESS','HSBCJLFS','MSCREDIT','HSBCCORPORATE','HSBCMALTA')
AND DATAVERSION IS NOT NULL) group by RULEMNEMONIC;

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

***** How to purge old data from sys.$aud table***********************

-- Checking size of sys.aud$ table :
++++++++++++++++++++++++++++++++++++++++++++++++

SQL> select OWNER,SEGMENT_NAME,BYTES/1024/1024 size_in_gb from dba_segments where OWNER='SYS' and SEGMENT_NAME='AUD$';

OWNER                          SEGMENT_NAME             SIZE_IN_GB
------------------------------ ------------------------ ----------
SYS                            AUD$                        452



Checking no. od days of data in sys.aud# :
++++++++++++++++++++++++++++++++++++++++++++++++++++++


SQL> select min(NTIMESTAMP#) from sys.aud$;

MIN(NTIMESTAMP#)
------------------------------
30-MAR-12 06.42.18.375298 PM

SQL> select max(NTIMESTAMP#) from sys.aud$;

MAX(NTIMESTAMP#)
-------------------------------
12-NOV-14 03.29.06.229288 PM


Delete data older than 90 days:
++++++++++++++++++++++++++++++++++++

delete from sys.aud$ where ntimestamp# < sysdate-90;

**********************************************************************************


**************** ADRCI ***************
adrci> show incident

adrci> show incidents -last 10

adrci> show incidents -all

ADR Home = /u01/app/oracle/diag/rdbms/*****/*******:
*************************************************************************
INCIDENT_ID          PROBLEM_KEY                                                 CREATE_TIME
-------------------- ----------------------------------------------------------- ----------------------------------------
197007               ORA 445                                                     2014-07-24 20:02:26.324000 -05:00
197207               ORA 445                                                     2014-07-24 20:04:26.191000 -05:00
455927               ORA 7445 [opiaba()+708]                                     2014-10-09 17:36:05.354000 -05:00
455928               ORA 600 [kghGetHpSz1]                                       2014-10-09 17:36:40.498000 -05:00
455167               ORA 600 [17147]                                             2014-10-09 19:48:32.964000 -05:00
694281               ORA 7445 [opiaba()+708]                                     2015-04-07 17:54:13.775000 -05:00
692825               ORA 600 [17147]                                             2015-04-07 18:06:24.598000 -05:00

*********How to create package:

Based on Incident
adrci>IPS CREATE PACKAGE INCIDENT <incident_number>

adrci>IPS CREATE PACKAGE ( For creating empty package)

Based on Problem
adrci>IPS CREATE PACKAGE PROBLEM <problem_ID>

Based on time interval
adrci>IPS CREATE PACKAGE SECONDS sec
adrci>IPS CREATE PACKAGE TIME 'start_time' TO 'end_time'

*******Adding Incidents and files to the logical package :

adrci>IPS ADD INCIDENT incident_number PACKAGE package_number
adrci>IPS ADD FILE filespec PACKAGE package_number


***********Generate a physical incident package ********************
Once you have created a logical package using one of the above methods, next step is to generate a physical package
adrci>IPS GENERATE PACKAGE package_number IN path


You can also create logical package and generate physical package with just one command 
adrci>IPS PACK INCIDENT <incident_id> IN <directory>

*********************************************************************************************************
************ How to drop all object from a schema *************

select owner,object_type,count(object_name) from dba_objects where owner='<schema_name>' group by owner,object_type;

set heading off
set pages 50000
select 'drop table '||owner||'.'||table_name||' cascade constraints;' from dba_tables where owner = '<schema_name>';

purge dba_recyclebin;

select owner,object_type,count(object_name) from dba_objects where owner='<schema_name>' group by owner,object_type;

select 'drop '||object_type||' '|| object_name||  DECODE(OBJECT_TYPE,'TABLE',' CASCADE CONSTRAINTS;',';')  from dba_objects where owner = '<schema_name>' and object_type IN ('SYNONYM','SEQUENCE','PROCEDURE','VIEW');

alter session set current_schema=<schema_name>;

Now drop all the objects with the previous scripts.

***************************************************************

********* How to get list of SQLs that running for a particular tables for some time period *****

Step-1:  Check for snap id for the particular day using below query.
 
SELECT SNAP_ID,BEGIN_INTERVAL_TIME,END_INTERVAL_TIME FROM DBA_HIST_SNAPSHOT order by SNAP_ID;
 
Step-2:  With the help of snap id, run below sql to get output in html format.
 
SET PAGES 5000 TERM OFF FEEDBACK OFF MARKUP HTML ON PREFORMAT OFF ENTMAP ON
set verify off
spool June29_sql_detail.html
 
set lines 300
set long 9999999
select a.SESSION_ID, a.SAMPLE_TIME, a.USER_ID, (select username from dba_users where a.user_id=user_id) as username, b.SQL_ID, b.sql_text
from DBA_HIST_ACTIVE_SESS_HISTORY a, dba_hist_sqltext b 
where a.sql_id=b.sql_id and upper(b.sql_text) like '%CACHE_STATUS%' 
and a.snap_id>=8022 and a.snap_id<=8047;
spool off
set markup html off
EOF
 
Here 53363 is the begin snap id and 53386 the last snap id for Apr 20th.

***********************************************************************************************
************ BLOCK CHANGE TRACKING******************
When using Oracle block change tracking we see this procedure.  As data blocks change, the Change Tracking Writer (CTWR) background process tracks the changed blocks in a private area of memory. 

When a commit is issued against the data block, the block change tracking information is copied to a shared area in Large Pool called the CTWR buffer. During the checkpoint, the CTWR process writes the information from the CTWR RAM buffer to the change-tracking file.

SQL> alter database enable block change tracking;

SQL> alter database enable block change tracking using file '/u01/app/oracvle/mysid/data/block_change_tracking.dbf';

To disable this feature, you issue this command:

SQL> alter database disable block change tracking;

To monitor the status of block change tracking, you type:

SQL> select filename, status, bytes from   v$block_change_tracking;

STATUS       FILE                          BYTES
-----------  ----------------------------  --------------
ENABLED      /dba/backup/01_mf_yzmrr7.chg  10,000,000

We can view the size of the CTWR dba buffer by looking at v$sgastat:

SELECT * FROM v$sgastat WHERE name like 'CTWR%'; 


************* Enable/Disable STats gather ****************

BEGIN
dbms_auto_task_admin.enable(client_name => 'auto optimizer stats collection', operation => NULL, window_name => NULL);
dbms_auto_task_admin.enable(client_name => 'auto space advisor', operation => NULL, window_name => NULL);
dbms_auto_task_admin.enable(client_name => 'sql tuning advisor', operation => NULL, window_name => NULL);
END;


************************************************************************

ORA-01591: LOCK HELD BY IN-DOUBT DISTRIBUTED TRANSACTION STRING

select * from pending_trans$;

Select * from dba_2pc_pending where local_tran_id='606.36.301120';

Here, according to the situation before the commit is issued after the rollback.

commit  force  '606.36.301120';
rollback force  '606.36.301120';

https://anargodjaev.wordpress.com/2013/12/24/ora-01591-lock-held-by-in-doubt-distributed-transaction/


*********************** OPATCH ********************
cd $ORACLE_HOME/OPatch
./opatch lsinventory -detail >> Opatch.lst


*****************************************************

***** SYS password change:

select * from user$ where name='SYS';


mv orapwprodbop1 orapwprodbop1.bck.0122


orapwd file=orapwptbirp12 password=ind1ant3l3v1s10n entries=10;

******** DB link ***********
set lines 200 pages 2000
col HOST format a10
col DB_LINK format a10
col HOST format a10
col OWNER format a10
col DB_LINK format a15
select * from dba_db_links where DB_LINK='RPT_BRM_PIM';

OWNER           DB_LINK                             USERNAME             HOST                                     CREATED
--------------- ----------------------------------- -------------------- ---------------------------------------- ---------
PUBLIC          PHLODS003D.WORLD                    ALLPOINTS            t2a2                                     03-FEB-14


select DBMS_METADATA.GET_DDL('DB_LINK','RPT_BRM_PIM','PUBLIC') from dual;

CREATE PUBLIC DATABASE LINK "PHLODS003D.WORLD" CONNECT TO "ALLPOINTS" IDENTIFIED BY VALUES ':1' USING 't2a2'

**********************************

select 'alter table '||owner||'.'||table_name|| ' disable constraint ' ||constraint_name||';' from dba_constraints where owner='LDB_OWNER';

SELECT 'truncate table '|| owner|| '.' || object_name || ' cascade;' FROM dba_objects WHERE owner='LDB_SAND' and OBJECT_TYPE='TABLE';

************** How to unregister database from Catalog ***********

SQL> select db_key,dbid,name from rc_database where name='DELBIDW6';

    DB_KEY DBID NAME
---------- ---------- --------
 136678707 12480768 DELBIDW6

SQL> execute dbms_rcvcat.unregisterdatabase(136678707,12480768);

PL/SQL procedure successfully completed.

SQL> select db_key,dbid,name from rc_database where name='DELBIDW6';

no rows selected

**********************************************************
#############################Table partatin ################################################

TF:

set lines 500
select table_owner,table_name,count(*) from dba_tab_partitions where table_owner not in ('SYS','SYSTEM') group by table_owner,table_name order by TABLE_OWNER;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='SECS2' and table_name='ARACSLOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='SECS4' and table_name='ARACSLOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='SECS4' and table_name='ARCALLOUTXNDATA' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='SECS4' and table_name='ARESLOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='SECS4' and table_name='ARVELOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='SECS5' and table_name='ARACSLOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='SECS5' and table_name='ARESLOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='SECS5' and table_name='ARVELOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='SECS5' and table_name='ARCASE' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='SECS9' and table_name='ARCALLOUTXNDATA' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='TSYS' and table_name='ARACCTHOLDERAUTH' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='TSYS' and table_name='ARISSUERANSWERS' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='TSYS' and table_name='ARACSLOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='TSYS' and table_name='ARESLOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='TSYS' and table_name='ARVELOG' order by PARTITION_position;


RF:

select table_owner,table_name,count(*) from dba_tab_partitions where table_owner not in ('SYS','SYSTEM') group by table_owner,table_name order by TABLE_OWNER;
select table_owner,table_name,count(*) from dba_tab_partitions where table_owner='RFORT' group by table_owner,table_name order by TABLE_OWNER;

select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='RFORT' and table_name='ARRFSYSAUDITLOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='RFORT' and table_name='ARRFSYSAUDITLOG_3DSECURE' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='RFORT' and table_name='ARRF_CASE_TXN_3DSECURE' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='RFORT' and table_name='ARRFSYSAUDITLOG_3DSECURE_DW' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='RFORT' and table_name='ARRFDEVICEINFO' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='RFORT' and table_name='ARRFDEVICECONTEXT' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='RFORT' and table_name='ARRFUSERSTATEAUDITLOG' order by PARTITION_position;

AOK:

select table_owner,table_name,count(*) from dba_tab_partitions where table_owner not in ('SYS','SYSTEM') group by table_owner,table_name order by TABLE_OWNER;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='ARCOT' and table_name='AOK_USER_FLOW_LOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='ARCOT' and table_name='AOK_USER_AUDIT_LOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='ARCOT' and table_name='ARAUTHAUDITLOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='ARCOT' and table_name='ARCREDLOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='ARCOT_RF' and table_name='ARRFSYSAUDITLOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='ARCOT_RF' and table_name='ARRF_CASE_TXN' order by PARTITION_position;



 TO list partitons for a specific month. Just replace the month and year.

select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAMe,HIGH_VALUE from dba_tab_partitions where partition_name like '%JUL%14' order by 1;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,subPARTITION_NAME,TABLESPACE_NAMe,HIGH_VALUE from dba_tab_subpartitions where table_name='ARACSLOG' and table_owner='SECS5' and subPARTITION_NAME like '%JUL%';


select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAMe,HIGH_VALUE from dba_tab_partitions where partition_name like '%JUL%14%' order by 1;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,subPARTITION_NAME,TABLESPACE_NAMe,HIGH_VALUE from dba_tab_subpartitions where table_name='ARRFSYSAUDITLOG_3DSECURE_DW' and table_owner='RFORT' and subPARTITION_NAME like '%JUL%14%';

#######################################Goldengate##############################################
to start the process from the specific SCN and RBA value.

alter replicat RS5LBILL extseqno 64710 extrba 375603706;

ALTER EXTRACT E_F_12C, THREAD 1, BEGIN 2018-06-25 09:00:00
ALTER EXTRACT E_F_12C, THREAD 2, BEGIN 2018-06-25 09:00:00


alter extract E1BRMDV1  extseqno 1346.
alter extract E_F_12C  extseqno 3094 thread 1.
alter extract E_F_12C  extseqno 3095, thread 1

alter extract E_F_12C  extseqno 3109, thread 1
alter extract E_F_12C  extseqno 1733, thread 2

alter extract E_F_12C    3110, extrba 0, thread 1.
alter extract E_F_12C  extseq 3110, extrba 0.
alter extract E_F_12C  extseqno 3110, extrba 0.
alter extract E_F_12C  extseqno 3921, extrba 0, thread 1.
start E_F_12C.

***************to find the check ping information***************
info E_F_12C  showch.
alter extract E_F_12C  extseqno 3921, extrba 0, thread 1
alter extract E_F_12C  extseqno 3809, extrba 0, thread 2

alter extract E_F_11G  extseqno 7235, extrba 0, thread 1
alter extract E_F_11G  extseqno 4015, extrba 0, thread 2

alter replicat R_F_12C, extseqno 487, extrba 363763372;
START REPLICAT R_F_12C SKIPTRANSACTION
start E_F_12C.

rsync utility. rsync -avze ssh /backup/expdp/secs4_d1 oracle@10.22.44.41:/backup/expdp/.
###########################################################################################
***************************recreate_all_big_mview****************************************
[oracle@trident611 drop_create_mv]$ cat recreate_all_big_mview.sql
spool recreate_all_big_mview.txt append
alter session set parallel_force_local=true;
set echo on time on timing on


drop MATERIALIZED VIEW SECS4.ARESLOG_HRLY;

CREATE MATERIALIZED VIEW SECS4.ARESLOG_HRLY
LOGGING
TABLESPACE S4_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH') date_logged,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM secs4.ARESLOG
  GROUP BY bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH');

drop MATERIALIZED VIEW LOG ON SECS4.ARACCTHOLDERAUTH;

CREATE MATERIALIZED VIEW LOG ON SECS4.ARACCTHOLDERAUTH
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 252706816 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S4_MV_DATA
  WITH PRIMARY KEY, ROWID, SEQUENCE ( BANKID, DATEENABLED, ISABRIDGEDREGISTRATION, NUMDECLINES ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW SECS4.ARACCTHOLDERAUTH_HRLY;

CREATE MATERIALIZED VIEW SECS4.ARACCTHOLDERAUTH_HRLY
LOGGING
TABLESPACE S4_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH') DATEENABLED,
    COUNT(1) totalCount,
    COUNT(*) totalCount1,
    numdeclines
  FROM secs4.ARAcctHolderAuth
  GROUP BY bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH'),
    numdeclines;

drop  MATERIALIZED VIEW LOG ON SECS7.ARESLOG;

CREATE MATERIALIZED VIEW LOG ON SECS7.ARESLOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S7_MV_DATA
  WITH ROWID ( BANKID, DATELOGGED, ISABRIDGEDREGISTRATION, NUMAUTHFAILURES, RANGEID, STATUS ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW SECS7.ARESLOG_HRLY;

 CREATE MATERIALIZED VIEW SECS7.ARESLOG_HRLY
LOGGING
TABLESPACE S7_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH') date_logged,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM secs7.ARESLOG
  GROUP BY bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH');

drop MATERIALIZED VIEW LOG ON SECS5.ARACSLOG;

  CREATE MATERIALIZED VIEW LOG ON SECS5.ARACSLOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S5_MV_DATA
  WITH ROWID ( BANKID, PAREQTIME, PARESSTATUS, RANGEID, TXTYPE ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW LOG ON SECS5.ARESLOG;

  CREATE MATERIALIZED VIEW LOG ON SECS5.ARESLOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S5_MV_DATA
  WITH ROWID ( BANKID, DATELOGGED, ISABRIDGEDREGISTRATION, NUMAUTHFAILURES, RANGEID, STATUS ) INCLUDING NEW VALUES;


drop MATERIALIZED VIEW LOG ON SECS5.ARESLOG;

  CREATE MATERIALIZED VIEW LOG ON SECS5.ARESLOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S5_MV_DATA
  WITH ROWID ( BANKID, DATELOGGED, ISABRIDGEDREGISTRATION, NUMAUTHFAILURES, RANGEID, STATUS ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW LOG ON SECS5.ARVELOG;

  CREATE MATERIALIZED VIEW LOG ON SECS5.ARVELOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S5_MV_DATA
  WITH ROWID ( BANKID, RANGEID, VEREQTIME, VERESSTATUS ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW secs5.ARACSLOG_HRLY ;

CREATE MATERIALIZED VIEW secs5.ARACSLOG_HRLY
LOGGING
TABLESPACE S5_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT
    /*+ PARALLEL(a,4) */
    bankid,
    rangeid,
    paresstatus,
    txtype,
    TRUNC(pareqtime,'HH') pareqtime,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM SECS5.ARACSLOG a
  GROUP BY bankid,
    rangeid,
    paresstatus,
    txtype,
    TRUNC(pareqtime,'HH');

drop  MATERIALIZED VIEW secs5.ARESLOG_HRLY ;

CREATE MATERIALIZED VIEW secs5.ARESLOG_HRLY
LOGGING
TABLESPACE S5_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH') date_logged,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM SECS5.ARESLOG
  GROUP BY bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH');

drop MATERIALIZED VIEW secs5.ARESLOG_STATUS_HRLY;

CREATE MATERIALIZED VIEW secs5.ARESLOG_STATUS_HRLY
LOGGING
TABLESPACE S5_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT BANKID,
    STATUS,
    COUNT(STATUS) STATUSCOUNT,
    TRUNC(datelogged,'HH') datelogged,
    COUNT(1) totalcount,
    COUNT(*) totalcounT1
  FROM secs5.ARESLOG
  GROUP BY BANKID,
    STATUS,
    TRUNC(datelogged,'HH');

drop MATERIALIZED VIEW secs5.ARVELOG_HRLY;

CREATE MATERIALIZED VIEW secs5.ARVELOG_HRLY
LOGGING
TABLESPACE S5_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT
    /*+ PARALLEL(a,4) */
    bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH') vereqtime,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM SECS5.ARVELOG a
  GROUP BY bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH');

drop MATERIALIZED VIEW LOG ON SECS7.ARVELOG;

CREATE MATERIALIZED VIEW LOG ON SECS7.ARVELOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S7_MV_DATA
  WITH ROWID ( BANKID, RANGEID, VEREQTIME, VERESSTATUS ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW SECS7.ARVELOG_HRLY;

CREATE MATERIALIZED VIEW SECS7.ARVELOG_HRLY
LOGGING
TABLESPACE S7_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT
    /*+ PARALLEL(a,4) */
    bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH') vereqtime,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM SECS7.ARVELOG a
  GROUP BY bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH');

drop MATERIALIZED VIEW LOG ON SECS7.ARACCTHOLDERAUTH;

CREATE MATERIALIZED VIEW LOG ON SECS7.ARACCTHOLDERAUTH
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S7_MV_DATA
  WITH PRIMARY KEY, ROWID ( BANKID, DATEENABLED, ISABRIDGEDREGISTRATION, NUMDECLINES ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW SECS7.ARACCTHOLDERAUTH_HRLY;

 CREATE MATERIALIZED VIEW SECS7.ARACCTHOLDERAUTH_HRLY
LOGGING
TABLESPACE S7_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH') DATEENABLED,
    COUNT(1) totalCount,
    COUNT(*) totalCount1,
    numdeclines
  FROM secs7.ARAcctHolderAuth
  GROUP BY bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH'),
    numdeclines;

spool off
[oracle@trident611 drop_create_mv]$
************************************************************************************************
*******************************************create_s7_ARVELOG************************************
[oracle@trident611 drop_create_mv]$ cat create_s7_ARVELOG.sql
spool create_s7_ARVELOG.txt

CREATE MATERIALIZED VIEW LOG ON "SECS7"."ARVELOG"
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "S7_MV_DATA"
  WITH ROWID ( "BANKID", "RANGEID", "VEREQTIME", "VERESSTATUS" ) INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW SECS7.ARVELOG_HRLY
LOGGING
TABLESPACE S7_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT
    /*+ PARALLEL(a,4) */
    bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH') vereqtime,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM SECS7.ARVELOG a
  GROUP BY bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH');

spool off;

[oracle@trident611 drop_create_mv]$
********************************************************************************************
********************************reate_s7_ARACCTHOLDERAUTH***********************************
[oracle@trident611 drop_create_mv]$ cat create_s7_ARACCTHOLDERAUTH.sql
spool create_s7_ARACCTHOLDERAUTH.txt

CREATE MATERIALIZED VIEW LOG ON "SECS7"."ARACCTHOLDERAUTH"
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "S7_MV_DATA"
  WITH PRIMARY KEY, ROWID ( "BANKID", "DATEENABLED", "ISABRIDGEDREGISTRATION", "NUMDECLINES" ) INCLUDING NEW VALUES;

 CREATE MATERIALIZED VIEW SECS7.ARACCTHOLDERAUTH_HRLY
LOGGING
TABLESPACE S7_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH') DATEENABLED,
    COUNT(1) totalCount,
    COUNT(*) totalCount1,
    numdeclines
  FROM secs7.ARAcctHolderAuth
  GROUP BY bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH'),
    numdeclines;

spool off;
**********************************************************************************************
******************************	create_s4_ARACSLOG ******************************************&*
[oracle@trident611 drop_create_mv]$ cat create_s4_ARACSLOG.sql
spool create_s4_ARACSLOG.txt

CREATE MATERIALIZED VIEW LOG ON "SECS4"."ARACSLOG"
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "S4_MV_DATA"
  WITH PRIMARY KEY, ROWID, SEQUENCE ( "BANKID", "PARESSTATUS", "RANGEID", "TXTYPE" ) INCLUDING NEW VALUES;


CREATE MATERIALIZED VIEW SECS4.ARACSLOG_HRLY
LOGGING
TABLESPACE S4_TAB_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    rangeid,
    paresstatus,
    txtype,
    TRUNC(pareqtime,'HH') pareqtime,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM secs4.ARACSLOG
  GROUP BY bankid,
    rangeid,
    paresstatus,
    txtype,
    TRUNC(pareqtime,'HH');

spool off;
**********************************************************************************************************
*********************************create_s4_ARVELOG******************************************************
[oracle@trident611 drop_create_mv]$ cat create_s4_ARVELOG.sql
spool create_s4_ARVELOG.txt

CREATE MATERIALIZED VIEW LOG ON "SECS4"."ARVELOG"
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "S4_MV_DATA"
  WITH ROWID, SEQUENCE ( "BANKID", "RANGEID", "VEREQTIME", "VERESSTATUS" ) INCLUDING NEW VALUES;


CREATE MATERIALIZED VIEW SECS4.ARVELOG_HRLY
LOGGING
TABLESPACE S4_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT
 /*+ PARALLEL(a,4) */
 bankid,
 rangeid,
 veresstatus,
 TRUNC(vereqtime,'HH') vereqtime,
 COUNT(1) totalcount,
 COUNT(*) totalcount1
 FROM
 SECS4.ARVELOG a
 GROUP BY
 bankid,
 rangeid,
 veresstatus,
 TRUNC(vereqtime,'HH');

spool off;
****************************************************************************************************
*****************************************create_s4_ARESLOG **************************************
[oracle@trident611 drop_create_mv]$ cat create_s4_ARESLOG.sql
spool create_s4_ARESLOG.txt

CREATE MATERIALIZED VIEW LOG ON "SECS4"."ARESLOG"
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "S4_MV_DATA"
  WITH PRIMARY KEY, ROWID, SEQUENCE ( "BANKID", "DATELOGGED", "ISABRIDGEDREGISTRATION", "NUMAUTHFAILURES", "RANGEID", "STATUS" ) INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW SECS4.ARESLOG_HRLY
LOGGING
TABLESPACE S4_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH') date_logged,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM secs4.ARESLOG
  GROUP BY bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH');

spool off;
****************************************************************************************************
***************************create_s4_ARACCTHOLDERAUTH***********************************
[oracle@trident611 drop_create_mv]$ cat create_s4_ARACCTHOLDERAUTH.sql
spool create_s4_ARACCTHOLDERAUTH.txt

CREATE MATERIALIZED VIEW LOG ON "SECS4"."ARACCTHOLDERAUTH"
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 252706816 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "S4_MV_DATA"
  WITH PRIMARY KEY, ROWID, SEQUENCE ( "BANKID", "DATEENABLED", "ISABRIDGEDREGISTRATION", "NUMDECLINES" ) INCLUDING NEW VALUES;

CREATE MATERIALIZED VIEW SECS4.ARACCTHOLDERAUTH_HRLY
LOGGING
TABLESPACE S4_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH') DATEENABLED,
    COUNT(1) totalCount,
    COUNT(*) totalCount1,
    numdeclines
  FROM secs4.ARAcctHolderAuth
  GROUP BY bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH'),
    numdeclines;

spool off;
****************************************************************************************************
*********************************create_tsys_ARACCTHOLDERAUTH***************************************
[oracle@trident611 drop_create_mv]$ cat create_tsys_ARACCTHOLDERAUTH.sql
spool create_tsys_ARACCTHOLDERAUTH.txt

drop  MATERIALIZED VIEW LOG ON TSYS.ARACCTHOLDERAUTH;

CREATE MATERIALIZED VIEW LOG ON TSYS.ARACCTHOLDERAUTH
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE TSYS_MV_DATA
  WITH PRIMARY KEY, ROWID ( BANKID, DATEENABLED, ISABRIDGEDREGISTRATION, NUMDECLINES ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW TSYS.ARACCTHOLDERAUTH_HRLY;

CREATE MATERIALIZED VIEW TSYS.ARACCTHOLDERAUTH_HRLY
LOGGING
TABLESPACE TSYS_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH') DATEENABLED,
    COUNT(1) totalCount,
    COUNT(*) totalCount1,
    numdeclines
  FROM tsys.ARAcctHolderAuth
  GROUP BY bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH'),
    numdeclines;

spool off;
*******************************************************************************************************
***************************************create_s2_ARVELOG***************************************
[oracle@trident611 drop_create_mv]$ cat create_s2_ARVELOG.sql
spool create_sesc2_ARVELOG.txt

drop MATERIALIZED VIEW LOG ON SECS2.ARVELOG;

CREATE MATERIALIZED VIEW LOG ON SECS2.ARVELOG
PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
TABLESPACE S2_MV_DATA
WITH ROWID, SEQUENCE ( BANKID, RANGEID, VEREQTIME, VERESSTATUS ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW SECS2.ARVELOG_HRLY;

CREATE MATERIALIZED VIEW SECS2.ARVELOG_HRLY
LOGGING
TABLESPACE S2_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT
    /*+ PARALLEL(a,4) */
    bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH') vereqtime,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM SECS2.ARVELOG a
  GROUP BY bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH');

spool off;
*******************************************************************************************************
********************************create_s2_ARESLOG****************************************
[oracle@trident611 drop_create_mv]$ cat create_s2_ARESLOG.sql
spool create_sesc2_ARESLOG.txt

drop  MATERIALIZED VIEW LOG ON SECS2.ARESLOG;

CREATE MATERIALIZED VIEW LOG ON SECS2.ARESLOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S2_MV_DATA
  WITH PRIMARY KEY, ROWID, SEQUENCE ( BANKID, DATELOGGED, ISABRIDGEDREGISTRATION, NUMAUTHFAILURES, RANGEID, STATUS ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW SECS2.ARESLOG_HRLY;

CREATE MATERIALIZED VIEW SECS2.ARESLOG_HRLY
LOGGING
TABLESPACE S2_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH') date_logged,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM SECS2.ARESLOG
  GROUP BY bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH');

spool off;
******************************************************************************************\
****************************create_tsys_ARVELOG*****************************************
[oracle@trident611 drop_create_mv]$ cat create_tsys_ARVELOG.sql
spool create_tsys_ARVELOG.txt

drop MATERIALIZED VIEW LOG ON TSYS.ARVELOG;

CREATE MATERIALIZED VIEW LOG ON TSYS.ARVELOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE TSYS_MV_DATA
  WITH ROWID ( BANKID, RANGEID, VEREQTIME, VERESSTATUS ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW TSYS.ARVELOG_HRLY;


CREATE MATERIALIZED VIEW TSYS.ARVELOG_HRLY
LOGGING
TABLESPACE TSYS_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT
    /*+ PARALLEL(a,4) */
    bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH') vereqtime,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM TSYS.ARVELOG a
  GROUP BY bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH');

spool off;
***********************************************************************************************
*********************************create_s7_ARACSLOG*******************************************
[oracle@trident611 drop_create_mv]$ cat create_s7_ARACSLOG.sql
spool create_s7_ARACSLOG.txt

drop MATERIALIZED VIEW LOG ON SECS7.ARACSLOG;

CREATE MATERIALIZED VIEW LOG ON SECS7.ARACSLOG
 PCTFREE 10 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S7_MV_DATA
  WITH ROWID ( BANKID, PAREQTIME, PARESSTATUS, RANGEID, TXTYPE ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW SECS7.ARACSLOG_HRLY;

CREATE MATERIALIZED VIEW SECS7.ARACSLOG_HRLY
LOGGING
TABLESPACE S7_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    rangeid,
    paresstatus,
    txtype,
    TRUNC(pareqtime,'HH') pareqtime,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM secs7.ARACSLOG
  GROUP BY bankid,
    rangeid,
    paresstatus,
    txtype,
    TRUNC(pareqtime,'HH');

spool off;
***********************************************************************************************
*********************************create_s7_ARESLOG.sql*******************************************
[oracle@trident611 drop_create_mv]$ cat create_s7_ARESLOG.sql
spool create_s7_ARESLOG.txt

set echo on time on timing on

drop  MATERIALIZED VIEW LOG ON SECS7.ARESLOG;

CREATE MATERIALIZED VIEW LOG ON SECS7.ARESLOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S7_MV_DATA
  WITH ROWID ( BANKID, DATELOGGED, ISABRIDGEDREGISTRATION, NUMAUTHFAILURES, RANGEID, STATUS ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW SECS7.ARESLOG_HRLY;

 CREATE MATERIALIZED VIEW SECS7.ARESLOG_HRLY
LOGGING
TABLESPACE S7_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH') date_logged,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM secs7.ARESLOG
  GROUP BY bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH');

spool off;
***********************************************************************************************
*********************************recreate_all_big_mview.sql************************************
[oracle@trident611 drop_create_mv]$ cat recreate_all_big_mview.sql
spool recreate_all_big_mview.txt append
alter session set parallel_force_local=true;
set echo on time on timing on


drop MATERIALIZED VIEW SECS4.ARESLOG_HRLY;

CREATE MATERIALIZED VIEW SECS4.ARESLOG_HRLY
LOGGING
TABLESPACE S4_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH') date_logged,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM secs4.ARESLOG
  GROUP BY bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH');

drop MATERIALIZED VIEW LOG ON SECS4.ARACCTHOLDERAUTH;

CREATE MATERIALIZED VIEW LOG ON SECS4.ARACCTHOLDERAUTH
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 252706816 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S4_MV_DATA
  WITH PRIMARY KEY, ROWID, SEQUENCE ( BANKID, DATEENABLED, ISABRIDGEDREGISTRATION, NUMDECLINES ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW SECS4.ARACCTHOLDERAUTH_HRLY;

CREATE MATERIALIZED VIEW SECS4.ARACCTHOLDERAUTH_HRLY
LOGGING
TABLESPACE S4_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH') DATEENABLED,
    COUNT(1) totalCount,
    COUNT(*) totalCount1,
    numdeclines
  FROM secs4.ARAcctHolderAuth
  GROUP BY bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH'),
    numdeclines;

drop  MATERIALIZED VIEW LOG ON SECS7.ARESLOG;

CREATE MATERIALIZED VIEW LOG ON SECS7.ARESLOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S7_MV_DATA
  WITH ROWID ( BANKID, DATELOGGED, ISABRIDGEDREGISTRATION, NUMAUTHFAILURES, RANGEID, STATUS ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW SECS7.ARESLOG_HRLY;

 CREATE MATERIALIZED VIEW SECS7.ARESLOG_HRLY
LOGGING
TABLESPACE S7_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH') date_logged,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM secs7.ARESLOG
  GROUP BY bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH');

drop MATERIALIZED VIEW LOG ON SECS5.ARACSLOG;

  CREATE MATERIALIZED VIEW LOG ON SECS5.ARACSLOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S5_MV_DATA
  WITH ROWID ( BANKID, PAREQTIME, PARESSTATUS, RANGEID, TXTYPE ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW LOG ON SECS5.ARESLOG;

  CREATE MATERIALIZED VIEW LOG ON SECS5.ARESLOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S5_MV_DATA
  WITH ROWID ( BANKID, DATELOGGED, ISABRIDGEDREGISTRATION, NUMAUTHFAILURES, RANGEID, STATUS ) INCLUDING NEW VALUES;


drop MATERIALIZED VIEW LOG ON SECS5.ARESLOG;

  CREATE MATERIALIZED VIEW LOG ON SECS5.ARESLOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S5_MV_DATA
  WITH ROWID ( BANKID, DATELOGGED, ISABRIDGEDREGISTRATION, NUMAUTHFAILURES, RANGEID, STATUS ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW LOG ON SECS5.ARVELOG;

  CREATE MATERIALIZED VIEW LOG ON SECS5.ARVELOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S5_MV_DATA
  WITH ROWID ( BANKID, RANGEID, VEREQTIME, VERESSTATUS ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW secs5.ARACSLOG_HRLY ;

CREATE MATERIALIZED VIEW secs5.ARACSLOG_HRLY
LOGGING
TABLESPACE S5_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT
    /*+ PARALLEL(a,4) */
    bankid,
    rangeid,
    paresstatus,
    txtype,
    TRUNC(pareqtime,'HH') pareqtime,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM SECS5.ARACSLOG a
  GROUP BY bankid,
    rangeid,
    paresstatus,
    txtype,
    TRUNC(pareqtime,'HH');

drop  MATERIALIZED VIEW secs5.ARESLOG_HRLY ;

CREATE MATERIALIZED VIEW secs5.ARESLOG_HRLY
LOGGING
TABLESPACE S5_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH') date_logged,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM SECS5.ARESLOG
  GROUP BY bankid,
    rangeid,
    status,
    numauthfailures,
    isabridgedregistration,
    TRUNC(datelogged,'HH');

drop MATERIALIZED VIEW secs5.ARESLOG_STATUS_HRLY;

CREATE MATERIALIZED VIEW secs5.ARESLOG_STATUS_HRLY
LOGGING
TABLESPACE S5_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT BANKID,
    STATUS,
    COUNT(STATUS) STATUSCOUNT,
    TRUNC(datelogged,'HH') datelogged,
    COUNT(1) totalcount,
    COUNT(*) totalcounT1
  FROM secs5.ARESLOG
  GROUP BY BANKID,
    STATUS,
    TRUNC(datelogged,'HH');

drop MATERIALIZED VIEW secs5.ARVELOG_HRLY;

CREATE MATERIALIZED VIEW secs5.ARVELOG_HRLY
LOGGING
TABLESPACE S5_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT
    /*+ PARALLEL(a,4) */
    bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH') vereqtime,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM SECS5.ARVELOG a
  GROUP BY bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH');

drop MATERIALIZED VIEW LOG ON SECS7.ARVELOG;

CREATE MATERIALIZED VIEW LOG ON SECS7.ARVELOG
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S7_MV_DATA
  WITH ROWID ( BANKID, RANGEID, VEREQTIME, VERESSTATUS ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW SECS7.ARVELOG_HRLY;

CREATE MATERIALIZED VIEW SECS7.ARVELOG_HRLY
LOGGING
TABLESPACE S7_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT
    /*+ PARALLEL(a,4) */
    bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH') vereqtime,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM SECS7.ARVELOG a
  GROUP BY bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH');

drop MATERIALIZED VIEW LOG ON SECS7.ARACCTHOLDERAUTH;

CREATE MATERIALIZED VIEW LOG ON SECS7.ARACCTHOLDERAUTH
 PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE S7_MV_DATA
  WITH PRIMARY KEY, ROWID ( BANKID, DATEENABLED, ISABRIDGEDREGISTRATION, NUMDECLINES ) INCLUDING NEW VALUES;

drop MATERIALIZED VIEW SECS7.ARACCTHOLDERAUTH_HRLY;

 CREATE MATERIALIZED VIEW SECS7.ARACCTHOLDERAUTH_HRLY
LOGGING
TABLESPACE S7_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH') DATEENABLED,
    COUNT(1) totalCount,
    COUNT(*) totalCount1,
    numdeclines
  FROM secs7.ARAcctHolderAuth
  GROUP BY bankid,
    IsAbridgedRegistration,
    TRUNC(DATEENABLED,'HH'),
    numdeclines;

spool off
***********************************************************************************************
*********************************drop_create_s5_ARVELOG.sql************************************
[oracle@trident611 drop_create_mv]$ cat drop_create_s5_ARVELOG.sql
spool drop_create_s5_ARVELOG.txt

drop MATERIALIZED VIEW LOG ON SECS5.ARVELOG;

CREATE MATERIALIZED VIEW LOG ON SECS5.ARVELOG
PCTFREE 60 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING
STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
TABLESPACE S5_MV_DATA
WITH ROWID ( BANKID, RANGEID, VEREQTIME, VERESSTATUS ) INCLUDING NEW VALUES;


drop MATERIALIZED VIEW secs5.ARVELOG_HRLY;

CREATE MATERIALIZED VIEW secs5.ARVELOG_HRLY
LOGGING
TABLESPACE S5_MV_DATA
PCTFREE 10
INITRANS 1
STORAGE
(
  INITIAL 65536
  NEXT 1048576
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
  BUFFER_POOL DEFAULT
)
NOCOMPRESS
NOCACHE
NOPARALLEL
USING INDEX
REFRESH ON DEMAND
FAST
USING DEFAULT LOCAL ROLLBACK SEGMENT
DISABLE QUERY REWRITE AS
SELECT
    /*+ PARALLEL(a,4) */
    bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH') vereqtime,
    COUNT(1) totalcount,
    COUNT(*) totalcount1
  FROM SECS5.ARVELOG a
  GROUP BY bankid,
    rangeid,
    veresstatus,
    TRUNC(vereqtime,'HH');

spool off;
********************************************************************************************************
alter table TSYS.ARVELOG truncate partition  TSYS_VELOG_MAY17 UPDATE GLOBAL INDEXES parallel 4;
alter table TSYS.ARVELOG truncate partition  TSYS_VELOG_JUN17 UPDATE GLOBAL INDEXES parallel 4;
alter table TSYS.ARVELOG truncate partition  TSYS_VELOG_JUL17 UPDATE GLOBAL INDEXES parallel 4;

Drop

alter table SECS2.ARESLOG drop partition  S2ESLOG_FEB17 UPDATE GLOBAL INDEXES parallel 4;
alter table SECS2.ARESLOG drop partition  S2ESLOG_MAR17 UPDATE GLOBAL INDEXES parallel 4;
alter table SECS2.ARESLOG drop partition  S2ESLOG_APR17 UPDATE GLOBAL INDEXES parallel 4;

(**********************************************

OEM Blockout 

export  AGENT_HOME=`cat /etc/oragchomelist|cut -d ":"  -f2`
$AGENT_HOME/bin/emctl  status blackout
$AGENT_HOME/bin/emctl  start blackout PDSRefresh -nodeLevel -d 06:00
echo "Check the status of blockout"
$AGENT_HOME/bin/emctl status blackout
**************************************************

*************AWS WEBS server connection*****************


BOIL161bc4505:.ssh spothu$ ssh -i bastion-west.pem ec2-user@34.208.236.25
********************************************************************************
This is a private computer system containing information that is proprietary
and confidential to the owner of the system.  Only individuals or entities
authorized by the owner of the system are allowed to access or use the system.
Any unauthorized access or use of the system or information is strictly
prohibited.

[ec2-user@ip-10-86-244-60 ~]$ ls
account_private_tomcat.pem  key_v2-4bf254b34f688.pem  obill-webs-dev-gghub.pem
[ec2-user@ip-10-86-244-60 ~]$ ssh -i obill-webs-dev-gghub.pem ec2-user@10.86.247.42
********************************************************************************
This is a private computer system containing information that is proprietary
and confidential to the owner of the system.  Only individuals or entities
authorized by the owner of the system are allowed to access or use the system.
Any unauthorized access or use of the system or information is strictly
prohibited.

All violators will be prosecuted to the fullest extent permitted by law.
********************************************************************************
Last login: Mon Jul  8 04:53:01 2019 from 10.86.244.60
********************************************************************************
This is a private computer system containing information that is proprietary
and confidential to the owner of the system.  Only individuals or entities
authorized by the owner of the system are allowed to access or use the system.
Any unauthorized access or use of the system or information is strictly
prohibited.

All violators will be prosecuted to the fullest extent permitted by law.
********************************************************************************
[ec2-user@ip-10-86-247-23 ~]$ sudo su - oracle
oracle:ip-10-86-247-23.vpc.internal/home/oracle->

********************************************************************************
********************************************************************************
*************************Tablespace cehck scripts in all servers***************

WITH res AS (
   SELECT
       a.*,
       round(100 - ( (allocated - used) / allocated) * 100,2) "Used_PCT"
   FROM
       (
           SELECT
               t.host_name,
               t.target_name,
               key_value tablespace_name,
               round(SUM(DECODE(metric_column,'spaceAllocated',value,0) ) / 1024,2) AS allocated,
               round(SUM(DECODE(metric_column,'spaceUsed',value,0) ) / 1024,2) AS used,
               round(SUM(DECODE(metric_column,'bytesFree',value,0) ) / 1024,2) AS free
           FROM
               mgmt$metric_current c,
               mgmt$target t
           WHERE
               t.target_name = c.target_name
               AND   metric_column IN (
                   'spaceAllocated',
                   'spaceUsed',
                   'bytesFree'
               )
           GROUP BY
               t.host_name,
               t.target_name,
               key_value
       ) a
   WHERE
       allocated - used > 0
       AND   round(100 - ( (allocated - used) / allocated) * 100,2) > 85
) SELECT
   host_name,
   target_name,
   tablespace_name,
   allocated,
   used,
   allocated - used AS free,
   round(100 - ( (allocated - used) / allocated) * 100,2) AS used_pct
 FROM
   res
ORDER BY
   1,
   2,
   7 DESC;
-- host: psysemmdbk01
user: sysman
-- OEM sysman: Em#13c_PPD$

sehydo447411

***************


  954  ./agentDeploy.sh -ignorePrereqs ORACLE_HOSTNAME=10.71.97.146 AGENT_BASE_DIR=/u01/app/oracle/product/agent13c OMS_HOST=ebsemmppd.intuit.net EM_UPLOAD_PORT=1159 AGENT_REGISTRATION_PASSWORD=Intuit01 AGENT_INSTANCE_HOME=/u01/app/oracle/product/agent13c/agent_inst b_doDiscovery=false START_AGENT=TRUE b_forceInstCheck=true -force AGENT_PORT=3872