********************** TABLESPACE ISSUES*************************
emcli login -username=sysman
emcli sync
emcli resyncAgent -agent=ip-10-94-188-160.vpc.internal:3872

eiamcli aws_creds -a 541393332662 -r PowerUser -p default

netstat -tupl|grep 9000

GG Install in silent mode :

 ./runInstaller -silent -showProgress -waitforcompletion -responseFile /u01/app/oracle/ogg19c/fbo_ggs_Linux_x64_shiphome/Disk1/response/oggcore.rsp

**************************Tele graph agent *********************

[root@ip-10-69-30-28 ~]# echo "AGENT=\"telegraf\"" > /etc/sysconfig/oim-agent
[root@ip-10-69-30-28 ~]# ps -ef|grep tele
root     80675 80552  0 23:37 pts/0    00:00:00 grep --color=auto telegraph
[root@ip-10-69-30-28 ~]# systemctl restart oim-agent
[root@ip-10-69-30-28 ~]# ps -ef|grep tele

****************************************************************

Time zone change 

sed -i 's/ZONE=\"UTC\"/ZONE=\"US\/Mountain\"/' /etc/sysconfig/clock
ln -sf /usr/share/zoneinfo/US/Mountain /etc/localtime

sed -i 's/ZONE=\"UTC\"/ZONE=\"US\/Pacific\"/' /etc/sysconfig/clock
ln -sf /usr/share/zoneinfo/US/Pacific /etc/localtime
****************************************************************

update casds.load_control
set processing_from_time = to_date('2019-09-09 00:00:00', 'yyyy-mm-dd
hh24:mi:ss'),
processing_to_time = to_date('2019-09-09 00:05:00', 'yyyy- mm-dd hh24:mi:ss');

Commit;

veridata startup:
--------
./veridataServer.sh start VERIDATA_server1 http://psysvrddbk01.corp.intuit.net:8830

*************
select * from VRDE2E_VERIDATA.JOB_RUNS where stop_date is null
update VRDE2E_VERIDATA.JOB_RUNS set stop_date=sysdate, status='F' where run_id='&run_id' ; 
If veridata e2e job is hung ^
**************
prf/e2e Veridata:
prf Veridata: 10.85.234.83
e2e Veridata: 10.85.200.82
eiamcli login
eiamCli getAWSTempCredentials -a 181299031239 -r AppOps -o 1 -p default
eiamCli getAWSTempSSHCert --awsAccountNumber 181299031239 --publicKeyName id_rsa -d ~/.ssh
prf Veridata:
ssh -L 8830:10.85.234.83:8830 -A 34.213.44.197
ssh 10.85.234.83
DB: rptpfw2b
Prd Veridata:
eiamcli login
eiamCli getAWSTempCredentials -a 316317974279 -r AppOps -o 1 -p default
eiamCli getAWSTempSSHCert --awsAccountNumber 316317974279 --publicKeyName id_rsa -d ~/.ssh
ssh -L 8830:10.81.104.83:8830 -A 52.38.56.140
username: weblogic
Password: to be shared over TinCan
Veridata DBs:
West SL-B RPT DBs
/u01/app/veridata/cron/veridata_report_new.sh
Report location: report_s3_path=s3://oii-veridata-${account_id}-${region}/reports/
weblogic/domain - start in nohup
nohup /u01/app/Oracle/Middleware/Oracle_Home/user_projects/domains/InfraDomain/veridata/bin/veridataServer.sh start &
nohup /u01/app/Oracle/Middleware/Oracle_Home/user_projects/domains/InfraDomain/bin/startWebLogic.sh &

*********************************

Agent installation:

***********For AWS EC2 Instance ****** 0.72.56.0/24--OEM***********

cd /u01/app/oracle/product/
mkdir agent13c
chown -R oracle:oinstall agent13c
cd agent13c
unzip /u01/app/oracle/product/install/13.4.0.0.0_AgentCore_226.zip -d /u01/app/software/agent_software
cd /u01/app/software/
chown -R oracle:oinstall agent_software
cd agent_software

  su - oracle -c "/u01/app/software/agent_software/agentDeploy.sh -ignorePrereqs ORACLE_HOSTNAME=$v_EC2_IP AGENT_BASE_DIR=/data/software/agent_13c OMS_HOST=10.77.146.60 EM_UPLOAD_PORT=1159 AGENT_REGISTRATION_PASSWORD=Intuit_123 AGENT_INSTANCE_HOME=/data/software/agent_13c/agent_inst b_doDiscovery=false START_AGENT=TRUE b_forceInstCheck=true -force AGENT_PORT=3872 -invPtrLoc = /opt/oracle/OraInventory" SCRATCHPATH=/u01/app/oracle/agent13c/
  
  /data/software/agent_13c/agent_13.2.0.0.0/root.sh

  su - oracle -c "/data/software/agent_13c/agent_inst/bin/emctl config agent addinternaltargets "
    su - oracle -c "/data/software/agent_13c/agent_inst/bin/emctl config agent listtargets "
    su - oracle -c "/data/software/agent_13c/agent_inst/bin/emctl upload "
    su - oracle -c "/data/software/agent_13c/agent_inst/bin/emctl status agent "

**************
To Deinstall:
/data/software/agent_13c/agent_13.4.0.0.0/perl/bin/perl /data/software/agent_13c/agent_13.4.0.0.0/sysman/install/AgentDeinstall.pl -agentHome /data/software/agent_13c/agent_13.4.0.0.0

Oracle Binaries installation:
----------------
oracle.install.option=INSTALL_DB_SWONLY
 UNIX_GROUP_NAME=oinstall
 INVENTORY_LOCATION=/u01/app/oraInventory
 ORACLE_HOME=/u01/app/oracle/product/12.2.0.1/dba_1
 ORACLE_BASE=/u01/app/oracle
 oracle.install.db.InstallEdition=EE
 oracle.install.db.OSDBA_GROUP=dba
 oracle.install.db.OSOPER_GROUP=dba
 oracle.install.db.OSBACKUPDBA_GROUP=dba
 oracle.install.db.OSDGDBA_GROUP=dba
 oracle.install.db.OSKMDBA_GROUP=dba
 oracle.install.db.OSRACDBA_GROUP=dba
 oracle.install.db.OSRACDBA_GROUP=dba
 SECURITY_UPDATES_VIA_MYORACLESUPPORT=false
 DECLINE_SECURITY_UPDATES=true
 
 
 
 10.72.62.15
 
 
 
 ./runInstaller -silent -responseFile /u01/app/oracle/product/12.2.0.1/db_1/database/response/db_install.rsp
 
***************
select tablespace_name from dba_tablespaces;

Tablespace [ORABPEL_TDE] is [95.09 percent] full 

select a.tbl "Name",
a.tsz "Total Size",
b.fsz "Free Space",
round((1-(b.fsz/a.tsz))*100) "Pct Used",
round((b.fsz/a.tsz)*100) "Pct Free" 
from 
(select tablespace_name tbl,
sum(bytes)/1024/1024/1024 TSZ 
from dba_data_files
where tablespace_name ='SC51420P_CLRT_INDX' 
group by tablespace_name) a,
(select tablespace_name tblsp,
sum(bytes)/1024/1024/1024 FSZ 
from dab_free_space
where tablespace_name ='SYSAUX' group by tablespace_name) b
Where a.tbl=b.tblsp;


SELECT ROUND(SUM(bytes/1024/1024/1024)) "USED_BYTES_IN_GB" ,
ROUND(SUM(CASE when maxbytes/1024/1024/1024 < bytes/1024/1024/1024 
then bytes/1024/1024/1024 
else maxbytes/1024/1024/1024 end )) "MAX_BYTES_IN_GB",
(ROUND(SUM(CASE when maxbytes/1024/1024/1024 < bytes/1024/1024/1024 
then bytes/1024/1024/1024 
else maxbytes/1024/1024/1024 end ))) - (ROUND(SUM(bytes/1024/1024/1024))) "AVAILABLE_IN_GB" 
from dba_data_files 
where tablespace_name='PIN00_ENC';


set linesize 300
col FILE_NAME format a70
col tablespace_name format a18
select tablespace_name, FILE_NAME, MAXBYTES/1024/1024/1024, BYTES/1024/1024/1024, AUTOEXTENSIBLE from dba_data_files where tablespace_name='XXRS';

set lines 200 pages 2000
select a.tablespace_name,a.alloc_size/1024/1024/1024 Allocated_size,a.cur_size/1024/1024/1024 Current_Size,(u.used+a.file_count*65536)/1024/1024/1024 Used_size,(a.alloc_size-(u.used+a.file_count*65536))/1024/1024/1024 Available_size
,((u.used+a.file_count*65536)*100)/a.alloc_size Pct_used from     dba_tablespaces t,(select t1.tablespace_name,nvl(sum(s.bytes),0) used from  dba_segments s,dba_tablespaces t1 where t1.tablespace_name=s.tablespace_name(+) group by t1.tablespace_name) u
,(select d.tablespace_name,sum(greatest(d.bytes,nvl(d.maxbytes,0))) alloc_size,sum(d.bytes) cur_size,count(*) file_count from dba_data_files d group by d.tablespace_name) a where t.tablespace_name=u.tablespace_name and t.tablespace_name=a.tablespace_name
and t.tablespace_name='XXRS' order by t.tablespace_name;

select file_name from dba_data_files where tablespace_name='UNDO_T1';

select TABLESPACE_NAME, FILE_NAME,AUTOEXTENSIBLE,MAXBYTES from dba_Data_files where TABLESPACE_NAME ='UNDO_T1';


SELECT DBMS_METADATA.get_ddl ('TABLESPACE', tablespace_name) FROM   dba_tablespaces WHERE  tablespace_name = DECODE(UPPER('&1'), 'ALL', tablespace_name, UPPER('&1'));

ALTER TABLESPACE PINX00 AUTOEXTEND ON MAXSIZE UNLIMITED;

select OWNER,table_name,round((blocks*8/1024),2) "size (Mb)" , round((num_rows*avg_row_len/1024/1024),2) "actual_data (Mb)", (round((blocks*8/1024),2) - round((num_rows*avg_row_len/1024/1024),2)) "wasted_space (Mb)" from dba_tables where OWNER='ORABPEL' ;

OMF FILE system:
-----------
 ALTER TABLESPACE PRSGATEDATA add datafile size 10G autoextend on maxsize 32767M;

SELECT name, type, total_mb, free_mb, required_mirror_free_mb, usable_file_mb,trunc(100-(free_mb/total_mb)*100,2) pct_used FROM V$ASM_DISKGROUP;																										
 
SELECT GROUP_NUMBER,NAME,TOTAL_MB/1024,FREE_MB/1024,USABLE_FILE_MB/1024 FROM V$ASM_DISKGROUP;
  
SQL> alter database datafile '/data/files/undotbs2.309.978026895' autoextend on maxsize 31G;


alter tablespace "UNDOTBS1" add datafile '/fs1/oracle/oradata/niku/undotbs04.dbf ' size 10G autoextend on maxsize 20G;

alter database datafile '********' autoextend on maxsize 25G;

ALTER DATABASE DATAFILE '********.dbf' RESIZE 15G;

ALTER TABLESPACE "$$$$$$" ADD DATAFILE '******.dbf' SIZE 3072M;

Note:For ASM, only diskgroup name is required to add a datafile

ALTER TABLESPACE "$$$$$$" ADD DATAFILE '+DATA' SIZE 5G autoextend on maxsize 32G;

*******************************To see full tablespace status in a database********************************

set lines 1000 pages 10000
SELECT  a.tablespace_name,
    ROUND (((c.BYTES - NVL (b.BYTES, 0)) / c.BYTES) * 100,2) percentage_used,
    c.BYTES/1024/1024/1024 space_allocated,
    ROUND (c.BYTES/1024/1024/1024 - NVL (b.BYTES, 0)/1024/1024/1024,2) space_used,
    ROUND (NVL (b.BYTES, 0)/1024/1024/1024, 2) space_free, 
    c.DATAFILES
  FROM dba_tablespaces a,
       (    SELECT   tablespace_name, 
                  SUM (BYTES) BYTES
           FROM   dba_free_space
       GROUP BY   tablespace_name
       ) b,
      (    SELECT   COUNT (1) DATAFILES, 
                  SUM (BYTES) BYTES, 
                  tablespace_name
           FROM   dba_data_files
       GROUP BY   tablespace_name
    ) c
  WHERE b.tablespace_name(+) = a.tablespace_name 
    AND c.tablespace_name(+) = a.tablespace_name
ORDER BY NVL (((c.BYTES - NVL (b.BYTES, 0)) / c.BYTES), 0) DESC;

==========================================================================


spool /tmp/current_status_info_new.txt
set pagesize 20000
set linesize 180
set pause off
set serveroutput on
set feedback on
set echo on
set numformat 999999999999999
alter session set nls_date_format = 'dd-mon-yyyy hh24:mi:ss';
archive log list;
select name,dbid,controlfile_type,open_mode,log_mode,checkpoint_change#,archive_change# from v$database;
select * from v$database_incarnation;
col name for a75
select * from v$restore_point;
select flashback_on from v$database;
select parallel from v$instance;
select protection_level from v$database;
select * from dba_streams_administrator;
select file#,name,status,checkpoint_change#,enabled from v$datafile;
select file#,name,status,enabled from v$tempfile;
select TS#,NAME,INCLUDED_IN_DATABASE_BACKUP,FLASHBACK_ON from v$tablespace;
select * from v$recover_file;
select * from v$backup;
select * from v$log;
select * from v$logfile;
select file#,name,recover,fuzzy,checkpoint_change#,creation_change#,checkpoint_time,creation_time,RESETLOGS_TIME,status from v$datafile_header;
select status, to_char(checkpoint_change#), to_char(checkpoint_time, 'DD-MON-YYYY HH24:MI:SS') as checkpoint_time,
count(*) from v$datafile_header
group by status, checkpoint_change#, checkpoint_time order by status, checkpoint_change#, checkpoint_time;
select count(*),fhsta from x$kcvfh group by fhsta;
select count(*),fhrba_seq from x$kcvfh group by fhrba_seq;
select count(*),fhscn from x$kcvfh group by fhscn;
select count(*),fhafs from x$kcvfh group by fhafs;
select min(FHSCN) "LOW FILEHDR SCN" , max(FHSCN) "MAX FILEHDR SCN", max(FHAFS) "Min PITR ABSSCN" from X$KCVFH ;
select fhdbn,fhdbi,hxfil,fhsta,fhscn,fhafs,fhrba_seq,fhtnm tbs_name from x$kcvfh;
select name, status , sequence#, thread#,
TO_CHAR(first_change#, '999999999999999999') as first_change#,
TO_CHAR(next_change#, '999999999999999999') next_change#,
to_char(completion_time,'DD-MON-YYYY HH24:MI:SS') completion_time
from v$archived_log where (select min(checkpoint_change#) from v$datafile_header) between first_change# and next_change#;
spool off
exit 


***************************************


select TABLESPACE_NAME, FILE_NAME,AUTOEXTENSIBLE,MAXBYTES from dba_Data_files where TABLESPACE_NAME like 'ORABPEL';
*****************************AWS RDS space*************************

set pages 200
select
'===========================================================' || chr(10) ||
'Total Database Physical Size = ' || round(redolog_size_gb+dbfiles_size_gb+tempfiles_size_gb+ctlfiles_size_gb,2) || ' GB' || chr(10) ||
'===========================================================' || chr(10) ||
' Redo Logs Size : ' || round(redolog_size_gb,3) || ' GB' || chr(10) ||
' Data Files Size : ' || round(dbfiles_size_gb,3) || ' GB' || chr(10) ||
' Temp Files Size : ' || round(tempfiles_size_gb,3) || ' GB' || chr(10) ||
' Archive Log Size - Approx only : ' || round(archlog_size_gb,3) || ' GB' || chr(10) ||
' Control Files Size : ' || round(ctlfiles_size_gb,3) || ' GB' || chr(10) ||
'===========================================================' || chr(10) ||
' Used Database Size : ' || used_db_size_gb || ' GB' || chr(10) ||
' Free Database Size : ' || free_db_size_gb || ' GB' ||chr(10) ||
' Data Pump Directory Size : ' || dpump_db_size_gb || ' GB' || chr(10) ||
' BDUMP Directory Size : ' || bdump_db_size_gb || ' GB' || chr(10) ||
' ADUMP Directory Size : ' || adump_db_size_gb || ' GB' || chr(10) ||
'===========================================================' || chr(10) ||
'Total Size (including Dump and Log Files) = ' || round(round(redolog_size_gb,2) +round(dbfiles_size_gb,2)+round(tempfiles_size_gb,2)+round(ctlfiles_size_gb,2) +round(adump_db_size_gb,2) +round(dpump_db_size_gb,2)+round(bdump_db_size_gb,2),2) || ' GB' || chr(10) ||
'===========================================================' as summary
FROM (SELECT sys_context('USERENV', 'DB_NAME')
db_name,
(SELECT SUM(bytes) / 1024 / 1024 / 1024 redo_size
FROM v$log)
redolog_size_gb,
(SELECT SUM(bytes) / 1024 / 1024 / 1024 data_size
FROM dba_data_files)
dbfiles_size_gb,
(SELECT nvl(SUM(bytes), 0) / 1024 / 1024 / 1024 temp_size
FROM dba_temp_files)
tempfiles_size_gb,
(SELECT SUM(blocks * block_size / 1024 / 1024 / 1024) size_gb
FROM v$archived_log
WHERE first_time >= SYSDATE - (
(SELECT value
FROM rdsadmin.rds_configuration
WHERE name =
'archivelog retention hours') /
24 ))
archlog_size_gb,
(SELECT SUM(block_size * file_size_blks) / 1024 / 1024 / 1024
controlfile_size
FROM v$controlfile)
ctlfiles_size_gb,
round(SUM(used.bytes) / 1024 / 1024 / 1024, 3)
db_size_gb,
round(SUM(used.bytes) / 1024 / 1024 / 1024, 3) - round(
free.f / 1024 / 1024 / 1024)
used_db_size_gb,
round(free.f / 1024 / 1024 / 1024, 3)
free_db_size_gb,
(SELECT round(SUM(filesize) / 1024 / 1024 / 1024, 3)
FROM TABLE(rdsadmin.rds_file_util.listdir('BDUMP')))
bdump_db_size_gb,
(SELECT round(SUM(filesize) / 1024 / 1024 / 1024, 3)
FROM TABLE(rdsadmin.rds_file_util.listdir('ADUMP')))
adump_db_size_gb,
(SELECT round(SUM(filesize) / 1024 / 1024 / 1024, 3)
FROM TABLE(rdsadmin.rds_file_util.listdir('DATA_PUMP_DIR')))
dpump_db_size_gb
FROM (SELECT bytes
FROM v$datafile
UNION ALL
SELECT bytes
FROM v$tempfile) used,
(SELECT SUM(bytes) AS f
FROM dba_free_space) free
GROUP BY free.f);

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&session and process count&&&&&&&&&&&&&&&&&&&&

SELECT RESOURCE_NAME, CURRENT_UTILIZATION, MAX_UTILIZATION, LIMIT_VALUE
FROM V$RESOURCE_LIMIT
WHERE RESOURCE_NAME IN ( 'sessions', 'processes');

********************Reclaim space query for tablespace**************

set linesize 1000 pagesize 0 feedback off trimspool on
with
 hwm as (
  -- get highest block id from each datafiles ( from x$ktfbue as we don't need all joins from dba_extents )
  select /*+ materialize */ ktfbuesegtsn ts#,ktfbuefno relative_fno,max(ktfbuebno+ktfbueblks-1) hwm_blocks
  from sys.x$ktfbue group by ktfbuefno,ktfbuesegtsn
 ),
 hwmts as (
  -- join ts# with tablespace_name
  select name tablespace_name,relative_fno,hwm_blocks
  from hwm join v$tablespace using(ts#)
 ),
 hwmdf as (
  -- join with datafiles, put 5M minimum for datafiles with no extents
  select file_name,nvl(hwm_blocks*(bytes/blocks),5*1024*1024) hwm_bytes,bytes,autoextensible,maxbytes
  from hwmts right join dba_data_files using(tablespace_name,relative_fno)
 )
select
 case when autoextensible='YES' and maxbytes>=bytes
 then -- we generate resize statements only if autoextensible can grow back to current size
  '/* reclaim '||to_char(ceil((bytes-hwm_bytes)/1024/1024),999999)
   ||'M from '||to_char(ceil(bytes/1024/1024),999999)||'M */ '
   ||'alter database datafile '''||file_name||''' resize '||ceil(hwm_bytes/1024/1024)||'M;'
 else -- generate only a comment when autoextensible is off
  '/* reclaim '||to_char(ceil((bytes-hwm_bytes)/1024/1024),999999)
   ||'M from '||to_char(ceil(bytes/1024/1024),999999)
   ||'M after setting autoextensible maxsize higher than current size for file '
   || file_name||' */'
 end SQL
from hwmdf
where
 bytes-hwm_bytes>1024*1024 -- resize only if at least 1MB can be reclaimed
order by bytes-hwm_bytes desc
/

****Query to see Current Temp Datafiles State*******


set pages 999
set lines 400
col FILE_NAME format a75
col TABLESPACE_NAME format a16
select d.TABLESPACE_NAME, d.FILE_NAME, d.BYTES/1024/1024/1024 SIZE_GB, d.AUTOEXTENSIBLE, d.MAXBYTES/1024/1024/1024 MAXSIZE_GB, d.INCREMENT_BY*(v.BLOCK_SIZE/1024)/1024/1024 INCREMENT_BY_GB
from dba_temp_files d,
 v$tempfile v
where d.FILE_ID = v.FILE#
order by d.TABLESPACE_NAME, d.FILE_NAME;


*****************Temp USAGE********************

SELECT A.tablespace_name tablespace, D.gb_total,
    SUM (A.used_blocks * D.block_size) / 1024 / 1024 /1024 gb_used,
    D.gb_total - SUM (A.used_blocks * D.block_size) / 1024 / 1024 /1024 gb_free
   FROM v$sort_segment A,
    (
   SELECT B.name, C.block_size, SUM (C.bytes) / 1024 / 1024 /1024 gb_total
    FROM v$tablespace B, v$tempfile C
     WHERE B.ts#= C.ts#
      GROUP BY B.name, C.block_size) D
    WHERE A.tablespace_name = D.name
    GROUP by A.tablespace_name, D.gb_total;
    
****Temp tablespace usage by user*******

COLUMN tablespace FORMAT A20 
COLUMN temp_size FORMAT A20 
COLUMN sid_serial FORMAT A20 
COLUMN username FORMAT A20 
COLUMN program FORMAT A40 
set line 200
SELECT b.tablespace, 
ROUND(((b.blocks*p.value)/1024/1024),2)||'M' AS temp_size, 
a.sid||','||a.serial# AS sid_serial, 
NVL(a.username, '(oracle)') AS username, 
a.program 
FROM v$session a, 
v$sort_usage b, 
v$parameter p 
WHERE p.name = 'db_block_size' 
AND a.saddr = b.session_addr 
ORDER BY b.tablespace, b.blocks;

SELECT b.tablespace, 
ROUND(((b.blocks*p.value)/1024/1024),2)||'M' AS temp_size, 
a.sid||','||a.serial# AS sid_serial, 
NVL(a.username, '(oracle)') AS username, 
a.program 
FROM v$session a, 
v$sort_usage b, 
v$parameter p 
WHERE p.name = 'db_block_size' 
AND a.saddr = b.session_addr 
ORDER BY b.blocks;


------Tablespace growth history----------

COL BEGIN_INTERVAL_TIME FORMAT A30
COL END_INTERVAL_TIME FORMAT A30

SELECT BEGIN_INTERVAL_TIME,END_INTERVAL_TIME,B.NAME,
ROUND((TABLESPACE_SIZE*8*1024)/1024/1024,2) SIZE_MB,
ROUND((TABLESPACE_MAXSIZE*8*1024)/1024/1024,2) MAXSIZE_MB,
ROUND((TABLESPACE_USEDSIZE*8*1024)/1024/1024,2) USEDSIZE_MB
FROM DBA_HIST_TBSPC_SPACE_USAGE A
JOIN V$TABLESPACE B ON (A.TABLESPACE_ID = B.TS#)
JOIN DBA_HIST_SNAPSHOT C ON (A.SNAP_ID = C.SNAP_ID)
WHERE NAME = 'TEMP02'
ORDER BY 1 DESC;

SELECT TS#, NAME FROM V$TABLESPACE WHERE NAME='TEMP';


SELECT (TABLESPACE_SIZE*16384)/1024/1024 "TOT MB",(TABLESPACE_USEDSIZE*16384)/1024/1024 "USE MB",RTIME 
FROM DBA_HIST_TBSPC_SPACE_USAGE 
WHERE TABLESPACE_ID = 3
ORDER BY RTIME

------ UNDO USAGE -----------

set lines 999 pages 9999 long 99999
COL "OS USER" FORMAT A10
COL "DB USER" FORMAT A10
COL "SCHEMA" FORMAT A10
COL "OBJECT NAME" FORMAT A25
COL "OBJECT TYPE" FORMAT A20
COL "RBS NAME" FORMAT A20
SELECT GVS.INST_ID "INSTANCE",
GVS.SID,
GLO.OS_USER_NAME "OS USER",
GLO.ORACLE_USERNAME "DB USER",
DBO.OWNER "SCHEMA",
SUBSTR (DBO.OBJECT_NAME, 1, 30) "OBJECT NAME",
SUBSTR (DBO.OBJECT_TYPE, 1, 10) "OBJECT TYPE",
SUBSTR (DRS.SEGMENT_NAME, 1, 15) "RBS NAME",
GVT.USED_UREC "# OF RECORDS",
GVT.USED_UBLK "# OF BLOCKS",
DRS.TABLESPACE_NAME "TABLESPACE"
FROM
GV$LOCKED_OBJECT GLO,
DBA_OBJECTS DBO,
DBA_ROLLBACK_SEGS DRS,
GV$TRANSACTION GVT,
GV$SESSION GVS
WHERE GLO.OBJECT_ID = DBO.OBJECT_ID
AND GLO.XIDUSN = DRS.SEGMENT_ID
AND GLO.XIDUSN = GVT.XIDUSN
AND GLO.XIDSLOT = GVT.XIDSLOT
AND GVT.ADDR = GVS.TADDR
AND GVT.USED_UBLK > 1000
ORDER BY GVT.USED_UBLK DESC;


SELECT TO_CHAR(S.SID)||','||TO_CHAR(S.SERIAL#) SID_SERIAL,
NVL(S.USERNAME, 'NONE') ORAUSER,
S.PROGRAM,
R.NAME UNDOSEG,
T.USED_UBLK * TO_NUMBER(X.VALUE)/1024||'K' "UNDO"
FROM SYS.V_$ROLLNAME R,
SYS.V_$SESSION S,
SYS.V_$TRANSACTION T,
SYS.V_$PARAMETER X
WHERE S.TADDR = T.ADDR
AND R.USN = T.XIDUSN(+)
AND X.NAME = 'DB_BLOCK_SIZE'
/

select a.used, b.allocated, round((a.used/b.allocated)*100,2) PCT_USED, c.unexpired, d.active from
(select sum(BYTES/1024/102/1024) used from dba_undo_extents where status in ('UNEXPIRED','ACTIVE')) a,
(select sum(bytes/1024/1024/1024)allocated from dba_data_files where tablespace_name like 'UNDOTBS1') b ,
(select sum(bytes/1024/1024/1024) unexpired from dba_undo_extents where status = 'UNEXPIRED') c,
(select sum(bytes/1024/1024/1024) active from dba_undo_extents where status = 'ACTIVE') d;


ACTIVE :- they are being used
UNEXPIRED :- they will not be released until the undo_retention time. 
But if all other extents are used, then oracle may reallocate unexpired blocks
and any session which is trying to read from unexpired block may received "snapshot too old error".
EXPIRED :- here these blocks will be reused, you can consider them as free.

***********************************************************************************************

**********************File system check ************************

select * 
from 
(
SELECT target_name host_name,decode(column_label,'Filesystem Size (MB)','Total_size(MB)','Filesystem Space Available (MB)','Available Space(MB)','Filesystem Space Available (%)','Available (%)') column_label,
key_value "Mountpoint", 
value
FROM mgmt$metric_current 
WHERE target_type = 'host' 
AND regexp_like (target_name , 'sys|pds|prf')
AND metric_name = 'Filesystems' 
and key_value like '/u%data%'
)
pivot  
(max(value)
       for (column_label) in
       ('Total_size(MB)'
      ,'Available Space(MB)'
      ,'Available (%)')
) where "'Available (%)'" <10
******************

COLUMN USERNAME FORMAT A15;
COLUMN SEGMENT_NAME FORMAT A15;
SELECT S.SID , S.USERNAME , T.USED_UBLK, ROUND((T.USED_UBLK*8)/1024) SIZE_IN_MB_8KB_BLOCK_SIZE, ROUND((T.USED_UBLK*16)/1024
) SIZE_IN_MB_16KB_BLOCK_SIZE
FROM V$TRANSACTION T
, V$SESSION S
WHERE 1 = 1
AND T.SES_ADDR = S.SADDR;



SELECT  a.sid, a.username, b.used_urec, b.used_ublk
FROM v$session a, v$transaction b
WHERE a.saddr = b.ses_addr
ORDER BY b.used_ublk DESC;


***Some troubleshooting for space issue***

SQL> select USERNAME,SQL_ID,TABLESPACE,SESSION_NUM from  v$tempseg_usage;

USERNAME   SQL_ID         TABLESPACE    SESSION_NUM
---------- ------------- --------------- -----------
DBSNMP    djj1j2x059xzh     TEMP              20


################# SESSION RELATED ############################

alter session set nls_date_format='DD-MON-YYYY HH24:MI:SS';

select sid,serial#,username,status,logon_time,sql_hash_value from v$session where sid=25671;

select sid,serial#,username,status,logon_time,sql_hash_value,sql_id from gv$session where USERNAME='BRM01' and sid=4085;

alter system kill session '280,2616' immediate;


begin
    rdsadmin.rdsadmin_util.kill(
        sid    => 24755, 
        serial => 16256,
        method => 'IMMEDIATE');
end;
/

3819,53477

col SCHEMANAME format a15
col OSUSER format a12
col STATUS format a10
col PROCESS format 999999
col MACHINE FORMAT A25

select username,status,count(*) from gv$session WHERE TYPE<>'BACKGROUND' and username not in ('SYS','TEMPDBA','DBSNMP','RDSADMIN') group by username,status;

select username,machine,status,count(*) from gv$session WHERE TYPE<>'BACKGROUND' and username not in ('SYS','TEMPDBA','DBSNMP','RDSADMIN') group by username,machine,status order by count(*) desc;

set lines 999 pages 9999 long 99999
col OSUSER format a12
alter session set nls_date_format='DD-MON-YY hh24:mi:ss';
select username,osuser,status,sql_id,machine,program,module,logon_time from v$session where TYPE<>'BACKGROUND' and username not in ('SYS','TEMPDBA','DBSNMP','RDSADMIN') and status='ACTIVE' and sql_id='&sql_id';

col USERNAME format a10
select username,status,sql_id,machine,count(*) from v$session where TYPE<>'BACKGROUND' and username not in ('SYS','TEMPDBA','DBSNMP','RDSADMIN') group by username,status,sql_id,machine;


select sid,serial#,status,sql_id,sql_exec_Start,logon_time,program,action,module,machine,osuser,service_name from v$session where sql_id='&sql_id';

select hash_value,sql_id,sql_text from v$sql where sql_id='a5kd860fm9fd3';

select inst_id,username,status,count(*) from gv$session WHERE sql_id='6fxf3tsm0syrz' and TYPE<>'BACKGROUND' and username not in ('SYS','TEMPDBA','DBSNMP','RDSADMIN') group by inst_id,username,status order by inst_id,count(*);

SELECT RESOURCE_NAME, CURRENT_UTILIZATION, MAX_UTILIZATION, LIMIT_VALUE FROM V$RESOURCE_LIMIT WHERE RESOURCE_NAME IN ( 'sessions', 'processes');
***************************************
-------------High cpu usage----------------
Displaying top CPU_consuming processes:
#ps aux | head -1; ps aux | sort -rn +2 | head -10 

Displaying top 10 memory-consuming processes:
#ps aux | head -1; ps aux | sort -rn +3 | head 

select
   ss.username,
   se.SID,
   VALUE/100 cpu_usage_seconds
from
   v$session ss,
   v$sesstat se,
   v$statname sn
where
   se.STATISTIC# = sn.STATISTIC#
and
   NAME like '%CPU used by this session%'
and
   se.SID = ss.SID
and
   ss.status='sho ACTIVE'
and
   ss.username is not null
order by VALUE desc;

********************************************
col username form A15
col sid form 9990
col type form A4
col lmode form 990
col request form 990
col id1 form 9999990
col id2 form 9999990

break on id1 skip 1 dup


SELECT sn.username, m.sid, m.type,
   DECODE(m.lmode, 0, 'None'
                 , 1, 'Null'
                 , 2, 'Row Share'
                 , 3, 'Row Excl.'
                 , 4, 'Share'
                 , 5, 'S/Row Excl.'
                 , 6, 'Exclusive'
                 , lmode, ltrim(to_char(lmode,'990'))) lmode,
   DECODE(m.request, 0, 'None'
                 , 1, 'Null'
                 , 2, 'Row Share'
                 , 3, 'Row Excl.'
                 , 4, 'Share'
                 , 5, 'S/Row Excl.'
                 , 6, 'Exclusive'
                 , request, ltrim(to_char(request,'990'))) request,
         m.id1,m.id2
FROM v$session sn, V$lock m
WHERE (sn.sid = m.sid AND m.request != 0)
   OR (sn.sid = m.sid
      AND m.request = 0 AND lmode != 4
      AND (id1, id2 ) IN (SELECT s.id1, s.id2
                          FROM v$lock s
                          WHERE request != 0
                                 AND s.id1 = m.id1
                                 AND s.id2 = m.id2 )
      )
ORDER BY id1,id2, m.request;

 ------To find sql id -------
 select sql_id, sql_text from v$sql where sql_text like '%SELECT SUPCAT_PRD_USRDEFATR.value%';


___ Blocking session queries ______
col USERNAME format a20
SELECT s.username,s.blocking_session,s.sid,s.serial#,s.seconds_in_wait FROM gv$session s WHERE blocking_session IS NOT NULL;

select 'alter system kill session '''||a.sid||','||a.serial#||''' immediate;' from gv$session a, v$process b where status='INACTIVE' and a.paddr=b.addr AND a.username='SIEBEL';

SELECT distinct a.sql_id ,a.inst_id,a.blocking_session,a.blocking_session_serial#,a.user_id,s.sql_text,a.module,a.sample_time
FROM GV$ACTIVE_SESSION_HISTORY a ,gv$sql s
where a.sql_id=s.sql_id
and blocking_session is not null
and a.user_id <> 0 -- exclude SYS user 
and a.sample_time > '04-oct-2018 09:45' ;


SELECT p.program, p.spid, s.sid, s.sql_id, s.status, s.event, s.wait_class, s.status, s.logon_time
FROM v$session s, v$process p
WHERE s.paddr = p.addr
AND p.spid in ('3080408','31195152','21233738','23330938','16842930','27656316','30998544');


select 'alter system kill session '''||a.sid||','||a.serial#||''' immediate;' from gv$session a, v$process b where status='INACTIVE' and a.paddr=b.addr AND a.username='BRM01';

SELECT 'alter system kill session '''|| s.sid|| ','|| s.serial#|| ''' immediate;' kill_sid FROM  gv$session s WHERE  username='DBADMIN' and sql_id='68w73sxt6ma2z';



SELECT status, count(*) AS session_count
FROM v$session
GROUP BY status;


-- Find all blocked sessions and who is blocking them
select sid,blocking_session,username,sql_id,event,machine,osuser,program,last_call_et from gv$session where blocking_session > 0;

select * from dba_blockers;
select * from dba_waiters;

-- Find what the blocking session is doing
select sid,serial#,status,blocking_session,username,sql_id,event,state,machine,osuser,program,last_call_et from gv$session where sid=1427;

-- Find the blocked objects
select owner,object_name,object_type from dba_objects where object_id in (select object_id from v$locked_object where session_id=2532 and locked_mode =3);


-- Friendly query for who is blocking who
-- Mostly for versions before v$session had blocking_session column
select s1.inst_id,s2.inst_id,s1.username || '@' || s1.machine
|| ' ( SID=' || s1.sid || ' )  is blocking '
|| s2.username || '@' || s2.machine || ' ( SID=' || s2.sid || ' ) ' AS blocking_status
  from gv$lock l1, gv$session s1, gv$lock l2, gv$session s2
  where s1.sid=l1.sid and s2.sid=l2.sid and s1.inst_id=l1.inst_id and s2.inst_id=l2.inst_id
  and l1.BLOCK=1 and l2.request > 0
  and l1.id1 = l2.id1
  and l2.id2 = l2.id2
order by s1.inst_id;


-- find blocking sessions that were blocking for more than 15 minutes + objects and sql
select s.SID,p.SPID,s.machine,s.username,CTIME/60 as minutes_locking, do.object_name as locked_object, q.sql_text
from v$lock l
join v$session s on l.sid=s.sid
join v$process p on p.addr = s.paddr
join v$locked_object lo on l.SID = lo.SESSION_ID
join dba_objects do on lo.OBJECT_ID = do.OBJECT_ID 
join v$sqlarea q on  s.sql_hash_value = q.hash_value and s.sql_address = q.address
where block=1 and ctime/60>10

-- Check who is blocking who in RAC
SELECT DECODE(request,0,'Holder: ','Waiter: ') || sid sess, id1, id2, lmode, request, type
FROM gv$lock
WHERE (id1, id2, type) IN (
  SELECT id1, id2, type FROM gv$lock WHERE request>0)
ORDER BY id1, request;

-- Check who is blocking who in RAC, including objects
SELECT DECODE(request,0,'Holder: ','Waiter: ') || gv$lock.sid sess, machine, do.object_name as locked_object,id1, id2, lmode, request, gv$lock.type
FROM gv$lock join gv$session on gv$lock.sid=gv$session.sid and gv$lock.inst_id=gv$session.inst_id
join gv$locked_object lo on gv$lock.SID = lo.SESSION_ID and gv$lock.inst_id=lo.inst_id
join dba_objects do on lo.OBJECT_ID = do.OBJECT_ID 
WHERE (id1, id2, gv$lock.type) IN (
  SELECT id1, id2, type FROM gv$lock WHERE request>0)
ORDER BY id1, request;




-- Who is blocking who, with some decoding
select sn.USERNAME,
       m.SID,
       sn.SERIAL#,
       m.TYPE,
       decode(LMODE,
              0, 'None',
              1, 'Null',
              2, 'Row-S (SS)',
              3, 'Row-X (SX)',
              4, 'Share',
              5, 'S/Row-X (SSX)',
              6, 'Exclusive') lock_type,
       decode(REQUEST,
              0, 'None', 
              1, 'Null',
              2, 'Row-S (SS)',
              3, 'Row-X (SX)', 
              4, 'Share', 
              5, 'S/Row-X (SSX)',
              6, 'Exclusive') lock_requested,
       m.ID1,
       m.ID2,
       t.SQL_TEXT
from   v$session sn, 
       v$lock m , 
       v$sqltext t
where t.ADDRESS = sn.SQL_ADDRESS 
and    t.HASH_VALUE = sn.SQL_HASH_VALUE 
and    ((sn.SID = m.SID and m.REQUEST != 0) 
or     (sn.SID = m.SID and m.REQUEST = 0 and LMODE != 4 and (ID1, ID2) in
        (select s.ID1, s.ID2 
         from v$lock S 
         where       REQUEST != 0 
         and s.ID1 = m.ID1 
         and s.ID2 = m.ID2)))
order by sn.USERNAME, sn.SID, t.PIECE;

-- Who is blocking whom, with some decoding
select OS_USER_NAME os_user,
       PROCESS os_pid,
       ORACLE_USERNAME oracle_user,
       l.SID oracle_id,
       decode(TYPE,
              'MR', 'Media Recovery',
              'RT', 'Redo Thread',
              'UN', 'User Name',
              'TX', 'Transaction',
              'TM', 'DML',
              'UL', 'PL/SQL User Lock',
              'DX', 'Distributed Xaction',
              'CF', 'Control File',
              'IS', 'Instance State',
              'FS', 'File Set',
              'IR', 'Instance Recovery',
              'ST', 'Disk Space Transaction',
              'TS', 'Temp Segment',
              'IV', 'Library Cache Invalidation',
              'LS', 'Log Start or Switch',
              'RW', 'Row Wait',
              'SQ', 'Sequence Number',
              'TE', 'Extend Table',
              'TT', 'Temp Table', type) lock_type,
       decode(LMODE,
              0, 'None',
              1, 'Null',
              2, 'Row-S (SS)',
              3, 'Row-X (SX)',
              4, 'Share',
              5, 'S/Row-X (SSX)',
              6, 'Exclusive', lmode) lock_held,
       decode(REQUEST,
              0, 'None',
              1, 'Null',
              2, 'Row-S (SS)',
              3, 'Row-X (SX)',
              4, 'Share',
              5, 'S/Row-X (SSX)',
              6, 'Exclusive', request) lock_requested,
       decode(BLOCK,
              0, 'Not Blocking',
              1, 'Blocking',
              2, 'Global', block) status,
       OWNER,
       OBJECT_NAME
from   v$locked_object lo,
       dba_objects do,
       v$lock l
where lo.OBJECT_ID = do.OBJECT_ID
AND     l.SID = lo.SESSION_ID
and block=1;



################################Finding Blocking session history#########################################

SELECT *
  FROM (SELECT a.sql_id,
               a.sample_time,
               COUNT (*)
               OVER (PARTITION BY a.blocking_session, a.user_id, a.program)
                  cpt,
               ROW_NUMBER ()
               OVER (PARTITION BY a.blocking_session, a.user_id, a.program
                     ORDER BY blocking_session, a.user_id, a.program)
                  rn,
               a.blocking_session,
               (SELECT object_name
                FROM dba_objects
                WHERE object_id = a.current_obj#
                 AND ROWNUM < 2) object_name,
                 (SELECT dbms_ROWID.ROWID_create (
                                        1,
                                        o.data_object_id,
                                        current_file#,
                                        current_block#,
                                        current_row#
                                        ) row_id 
                FROM dba_objects o 
                WHERE data_object_id=a.current_obj# and rownum<2
                )
                 BLOCKING_SESSION_STATUS,
                  decode(session_state, 'WAITING','Waiting',
                        'Working') state,
               a.user_id,
               a.program,
               s.sql_text
          FROM sys.dba_hist_ACTIVE_SESS_HISTORY a, sys.dba_hist_sqltext s
         WHERE     a.sql_id = s.sql_id
               AND blocking_session_serial# <> 0
               AND a.user_id <> 0
           AND a.sample_time >= TO_DATE (TRIM ('29-AUG-2024 09:45:00'), 'dd-mon-yyyy hh24:mi:ss')
           AND a.sample_time <= TO_DATE (TRIM ('29-AUG-2024 10:00:00 '), 'dd-mon-yyyy hh24:mi:ss')
ORDER BY a.sample_time)
WHERE rn = 1;


*************** Long running queries ******************************

select sid from v$session_wait
where
(event not in ( 'SQL*Net message from client','SQL*Net message to client',
'rdbms ipc message', 'smon timer', 'pmon timer', 'virtual circuit status',
'SQL*Net message from dblink','SQL*Net more data from dblink',
'PL/SQL lock timer','sbtbackup','imm op','jobq slave wait','i/o slave wait',
'sbtwrite2','io done','sbtclose2','sbtinit','sbtinfo2','sbtinit2','Backup: sbtwrite2','Backup: sbtbackup', 'VKTM Logical Idle Wait', 'fbar timer')
 and event not like 'Streams AQ:%')
 and seconds_in_wait > 30
 and sid > 12;

set lines 999 pages 9999 long 99999 
SELECT s.username,
       sl.sid,
       sl.last_update_time,
       sl.sql_id,
       target,
       elapsed_seconds,
       time_remaining,
       sq.sql_fulltext
FROM v$session_longops sl
INNER JOIN v$sql sq ON sq.sql_id = sl.sql_id
INNER JOIN v$session s ON sl.SID = s.SID AND sl.serial# = s.serial#
WHERE time_remaining > 30;


col %DONE for a10
col USERNAME for a20
col TARGET for a30
select b.username,a.sid,b.opname,b.target,round(b.SOFAR*100/b.TOTALWORK,0) || '%' as "%DONE",b.TIME_REMAINING,to_char(b.start_time,'YYYY/MM/DD HH24:MI:SS') START_TIME from V$SESSION_LONGOPS b,V$SESSION a where a.sid=b.sid order by 6;

col OSUSER format a10
select S.USERNAME, s.sid, s.osuser, t.sql_id, sql_text
from v$sqltext_with_newlines t,V$SESSION s
where t.address =s.sql_address
and t.hash_value = s.sql_hash_value
and s.status = 'ACTIVE'
--and s.username <> 'BRM01'
order by s.sid,t.piece
/
 
 
 set lines 200 pages 200
col OPNAME for a30
col TARGET for a30
col UNITS for a20
select INST_ID,SID,SERIAL#,OPNAME,TARGET,SOFAR,TOTALWORK,ROUND(SOFAR/TOTALWORK*100,2) " %_COMPLETE", TIME_REMAINING/3600 from gv$session_longops where time_remaining > 0 ;

select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,NUM_ROWS,LAST_ANALYZED from dba_tab_partitions where TABLE_OWNER ='SIEBEL' and TABLE_NAME in ('LEDGER_REPORT_ACCTS_T','INVOICE_FORMATS_BUF_T','EVENT_T','ITEM_T','BILL_T','BILLINFO_T','BAL_GRP_T','PURCHASED_PRODUCT_T','EVENT_BAL_IMPACTS_T');

col PARTITION_NAME format a20
col TABLE_NAME format a30
col TABLE_OWNER format a10
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,LAST_ANALYZED from dba_tab_partitions where TABLE_NAME='&TABLE_NAME' and TABLE_OWNER='&TABLE_OWNER';
*************Long running transaction***********

col opname format a30
col start_time format a20
col target format a30
col message format a80
select * from
(
  select
     opname,start_time,target,sofar,totalwork,units,elapsed_seconds,message
   from
        v$session_longops
  order by start_time desc
)
where rownum <=1;

*****************************************************************************
AWR-- Automatic Workload repository
ASH-- Active session history

How to pull AWR/ASH report from database:
	awrrpt.sql  or  awrddrpt.sql		@$ORACLE_HOME/rdbms/admin/awrrpt.sql
	ashrpt.sql  or  ashddrpt.sql		@$ORACLE_HOME/rdbms/admin/ashrpt.sql

@?/rdbms

@? -- ORACLE_HOME

*****************************************************************************

********************File system*********************************************

du -sk *
ls -lhrt

du -sh *|grep G

find . -name "core.oracle*" -mtime +20 -exec ls -lrt {} +

find . -name "server_*.trc" -mmin +360 -exec ls -lrt {} +

find . -name "inventory*" -mtime +3 -exec rm -rf {} +

find . -mtime +30 | xargs rm -Rf

ls -ltr *.trc | grep 'Oct 13 19:' | awk '{print "rm "$9}' | sh ;

ps -ef|grep "LOCAL=NO"| grep prdfin02|grep Apr|awk {'print $2'}
kill -9 `ps -ef|grep "LOCAL=NO"| grep prdfin02|grep Apr|awk {'print $2'}`

*************************************************************************

*************Number of disk to be monitored is larger than 1000*************

Go to the location: /u01/app/middleware/agent_inst/sysman/emd

emagent_storage.config
-> edit
-> increase Disks

Restart the agent 

How to check AGENT details
/u01/app/middleware/agent12c/agent_inst/bin/emctl status agent
/u01/app/middleware/agent12c/agent_inst/bin/emctl start blackout Agent_Restart -nodeLevel -d 01:00
/u01/app/middleware/agent12c/agent_inst/bin/emctl stop agent
/u01/app/middleware/agent12c/agent_inst/bin/emctl clearstate agent
/u01/app/middleware/agent12c/agent_inst/bin/emctl start agent
/u01/app/middleware/agent12c/agent_inst/bin/emctl stop blackout Agent_Restart 
/u01/app/middleware/agent12c/agent_inst/bin/emctl upload agent
*****************************************************************************

*********************crontab info*************************************

Crontab: Min,Hour,Day of month,Month,Day of week

A field may be an asterisk (*), which always stands for "first through last"

Field Descriptions:

minute  hour  dayOfMonth  month  dayOfWeek  command
where:
minute values range from 0 to 59, 
hour values range from 0 to 23, 
dayOfMonth values range from 1 to 31, 
month values range from 1 to 12, 
dayOfWeek values range from 0 to 6, with 0 meaning Sunday 
Field Values:


****crontab backup****

crontab -l > crontab_date_bkp

****How to restore****

crontab crontab_date_bkp

run {
allocate channel dev1 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
allocate channel dev2 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
allocate channel dev3 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
allocate channel dev4 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
crosscheck backup;
restore archivelog from sequence 51595 until sequence 51610;
}


run
{
allocate channel dev1 type sbt parms='SBT_LIBRARY=/data/dbs/S3_Bucket_Config/lib/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/data/dbs/S3_Bucket_Config/osbwsrvsprd01.ora)';
restore archivelog from logseq 364669 until logseq 364737 thread=1;
}

##################################Database restore generation script from Prod##############################
set pages 0
set lines 200
set feedback off
set heading off
spool rman_script.sh
prompt rman << ! > rman_perf_refresh.log
prompt connect auxiliary /
prompt run {
select 'allocate auxiliary channel a1 type disk ;' from dual;
select 'allocate auxiliary channel a2 type disk ;' from dual;
select 'allocate auxiliary channel a3 type disk ;' from dual;
select 'allocate auxiliary channel a4 type disk ;' from dual;
select 'allocate auxiliary channel a5 type disk ;' from dual;
select 'allocate auxiliary channel a6 type disk ;' from dual;
select 'set newname for datafile ' ||file_id|| ' to '''|| file_name|| ''';' from dba_data_files order by file_id;
select 'set newname for tempfile ' ||file_id|| ' to '''|| file_name|| ''';' from dba_temp_files order by file_id;
select 'DUPLICATE DATABASE TO $ORACLE_SID BACKUP LOCATION '||chr(39)||'/rman/production/ORACLE_SID'||chr(39)||' NOFILENAMECHECK ;' from dual;
prompt }
prompt !
spool off

***************************************************************************
#!/bin/sh

${ORACLE_HOME}/bin/rman <<EOF
connect target sys/Aru2M5-xs679@brm10prddb1
connect auxiliary sys/Aru2M5-xs679@brm10prddb2
duplicate target database for standby from active database nofilenamecheck;
EOF
!
exit;
***************************************************************************
racle@ip-10-72-150-83.vpc.internal:/data/rman_standby_rsync->cat incr_bkp_rman.sh
rman target / nocatalog @incr_bkp.rman log=Incr_scn_bkp.log
oracle@ip-10-72-150-83.vpc.internal:/data/rman_standby_rsync->cat incr_bkp.rman
run
{
allocate channel c1 type DISK;
allocate channel c2 type DISK;
allocate channel c3 type DISK;
allocate channel c4 type DISK;
allocate channel c5 type DISK;
allocate channel c6 type DISK;
allocate channel c7 type DISK;
allocate channel c8 type DISK;
allocate channel c9 type DISK;
allocate channel c10 type DISK;
allocate channel c11 type DISK;
allocate channel c12 type DISK;
allocate channel c13 type DISK;
allocate channel c14 type DISK;
allocate channel c15 type DISK;
allocate channel c16 type DISK;
allocate channel c17 type DISK;
allocate channel c18 type D ISK;
allocate channel c19 type DISK;
allocate channel c20 type DISK;
BACKUP AS COMPRESSED BACKUPSET INCREMENTAL FROM SCN 13057054793835  DATABASE FORMAT '/data/rman_standby_rsync/ForStandby_%U' tag 'FORSTANDBY';
 backup as compressed backupset device type disk FORMAT ‘/data/rman_restore/rman_full/%d_Full_Backup_%s_%p.bck’ tag=’FULL${currentdate}’ database plus archivelog delete all input tag=’ARCHIVE${currentdate}’;
}


alter database create standby controlfile as '/data/rman_standby_rsync/std_control.ctl';


****************************How to check current schema ******************************************
select sys_context('userenv','current_schema') from dual;

alter session set current_schema=BO_MERCH_STRATEGIC_PLANNING_AN;

************How to gather stats*************************************
exec dbms_stats.gather_schema_stats('ER_OWNER', method_opt => 'for all indexed columns size auto', degree => 4 ,cascade =>TRUE);

exec dbms_stats.gather_table_stats(ownname =>'TRIRIGA_OWNER', tabname =>'T_TRIPUNCHLISTTASK',estimate_percent =>20, method_opt => 'for all indexed columns size auto', cascade =>TRUE);

exec dbms_stats.gather_table_stats(ownname=>'ER_OWNER',tabname=>'SUM_EMP_HISTORY', method_opt => 'for all indexed columns size auto', degree => 8 ,cascade =>TRUE);

exec dbms_stats.gather_table_stats(ownname =>'PROFILEV5', tabname =>'DPS_USER',estimate_percent =>20, method_opt => 'for all indexed columns size auto', degree => 4 ,cascade =>TRUE);

analyze table DLPA_OWNER.INVOICE_HEADER compute statistics;

exec dbms_stats.gather_table_stats ('ER_OWNER','SUM_EMP_HISTORY',partname=>'FS4');

set lines 999 pages 9999 long 99999
col TABLE_OWNER format a16
col TABLE_NAME format a30
col PARTITION_NAME format a10
col LAST_ANALYZED format a30
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,NUM_ROWS,LAST_ANALYZED from dba_tab_partitions; where PARTITION_NAME in ('FS_4','FS_5','FS_6','FS_7');


set lines 999 pages 9999 long 99999
col owner format a10
col table_name format a30
SELECT owner, table_name, last_analyzed, stale_stats FROM dba_tab_statistics where owner='XXRS';

*********************************************************
********** How to find table size*******************

 col SEGMENT_NAME format a30
select segment_name,sum(bytes)/1024/1024/1024 from dba_segments where owner='&&OWNER' and segment_name='&&TABLE_NAME' group by segment_name;

**Partition size****
SELECT partition_name, bytes/1024/1024 "MB"
FROM dba_segments
WHERE segment_name = XXRS.XXDMR_REV_SCHEDULES_Q
AND segment_type = 'SYS_P6309';


select OWNER,table_name,round((blocks*8/1024),2) "size (Mb)" , 
                            round((num_rows*avg_row_len/1024/1024),2) "actual_data (Mb)",
                            (round((blocks*8/1024),2) - round((num_rows*avg_row_len/1024/1024),2)) "wasted_space (Mb)"
from dba_tables;
where table_name in ('AQ_SYNC_BAK_040712','AQ_SYNC_BK_040712','BKUP_CFG_GLID_ACCTS_T','BKUP_CFG_INTU_GL_GLID_MAP_T') and (round((blocks*8/1024),2) > round((num_rows*avg_row_len/1024/1024),2))
order by table_name;

*********** How to find database size (db size) ********************

select
  ( select sum(bytes)/1024/1024/1024 data_size from dba_data_files ) +
  ( select nvl(sum(bytes),0)/1024/1024/1024 temp_size from dba_temp_files ) +
  ( select sum(bytes)/1024/1024/1024 redo_size from sys.v_$log ) +
  ( select sum(BLOCK_SIZE*FILE_SIZE_BLKS)/1024/1024/1024 controlfile_size from v$controlfile) "Size in GB"
from dual;
	
select round(sum(used.bytes) / 1024 / 1024 /1024 ) || 'GB' "Database Size",
round(free.p / 1024 / 1024 /1024) || 'GB' "Free space" from
(select bytes from v$datafile union all select bytes from v$tempfile
union all select bytes from v$log) used,
(select sum(bytes) as p from dba_free_space) free group by free.p;


set lines 999 pages 9999 long 99999
column REDOLOG_FILE_NAME format a50
SELECT  a.GROUP#, a.THREAD#, a.SEQUENCE#, a.ARCHIVED, a.STATUS, b.MEMBER AS REDOLOG_FILE_NAME, (a.BYTES/1024/1024) AS SIZE_MB FROM gv$log a JOIN gv$logfile b ON a.Group#=b.Group# ORDER BY a.GROUP#;

select lf.group#,l_type.log_type as type, lf.member from v$logfile lf join (select group#,'ORL' as log_type from v$log union select group#,'SRL' as log_type from v$standby_log) l_type on lf.group#=l_type.group#
order by lf.group#;

------Utilized database space-------
select sum(BYTES/1024/1024/1024) from dba_segments;
	
Ho to find segment size as per owner

select owner, segment_name, round(sum(bytes)/1024/1024/1024,1) "GB"
from dba_segments
where owner not like '%SYS%'
having round(sum(bytes)/1024/1024/1024,1) > 10.0
group by owner, segment_name
UNION ALL
select 'ORACLE', 'DATABASE', round(sum(bytes)/1024/1024/1024,1) "GB"
from dba_segments
order by 3 desc

******schema size*****
select owner,sum(bytes)/1024/1024/1024 schema_size_gig from dba_segments group by owner;

select sum(bytes)/1024/1024/1024 as size_in_gig, segment_type from dba_segments where owner='PDC' group by segment_type;

********************* Database backup**********************************************

*****************To see startdate, enddate*****************

col STATUS format a25
col hrs format 999.99
set pagesize 300
set linesize 300
select
SESSION_KEY, INPUT_TYPE, STATUS,
to_char(START_TIME,'mm/dd/yy hh24:mi') start_time,
to_char(END_TIME,'mm/dd/yy hh24:mi')   end_time,
elapsed_seconds/3600                   hrs
from V$RMAN_BACKUP_JOB_DETAILS 
WHERE INPUT_TYPE='DB FULL' 
order by session_key;

************** To see startdate, enddate with backup size**********

COL INPUT_TYPE FOR A15
COL STATUS FOR A30
COL OUTPUT_BYTES_DISPLAY FOR A25
COL END_TIME FOR A20
COL START_TIME FOR A20
SET LINES 300 pages 100
col COMPRESSED_BKP_SIZE for a20
alter session set nls_date_format='dd-mon-yyyy hh24:mi:ss';
SELECT INPUT_TYPE ,STATUS,START_TIME,END_TIME,round(COMPRESSION_RATIO*OUTPUT_BYTES)/1024/1024/1024 "BKP_SIZE" ,(SELECT SUM(BYTES)/1024/1024/1024 FROM DBA_SEGMENTS) "DB_SIZE" 
FROM V$RMAN_BACKUP_JOB_DETAILS WHERE  input_type != 'ARCHIVELOG'  AND START_TIME>SYSDATE-30 order by start_time asc;


set lines 999 pages 9999 long 99999
col STATUS format a10
col hrs format 999.99
select SESSION_KEY, INPUT_TYPE, STATUS,to_char(START_TIME,'mm/dd/yy hh24:mi') start_time,
to_char(END_TIME,'mm/dd/yy hh24:mi') end_time,elapsed_seconds/3600 hrs from V$RMAN_BACKUP_JOB_DETAILS
order by session_key;



aws s3 ls s3://rman-045645906262/file_chunk/1528730869/RVSPRD01/backuppiece/2021-08-09/rvsprd01/

aws s3api delete-bucket-policy --bucket 687581231006-us-west-2-vtxprf9a-rman

COL INPUT_TYPE FOR A15
COL STATUS FOR A30
COL OUTPUT_BYTES_DISPLAY FOR A25
COL END_TIME FOR A20
COL START_TIME FOR A20
SET LINES 300 pages 100
col COMPRESSED_BKP_SIZE for a20
alter session set nls_date_format='dd-mon-yyyy hh24:mi:ss';
SELECT INPUT_TYPE ,STATUS,START_TIME,END_TIME,round(COMPRESSION_RATIO*OUTPUT_BYTES)/1024/1024/1024 "BKP_SIZE" ,(SELECT SUM(BYTES)/1024/1024/1024 FROM DBA_SEGMENTS) "DB_SIZE" 
FROM V$RMAN_BACKUP_JOB_DETAILS WHERE  input_type ='ARCHIVELOG'  AND START_TIME>SYSDATE-7 order by start_time asc;

Set lines 200 pages 200
col STATUS format a15
col hrs format 999.99
select SESSION_KEY, INPUT_TYPE, STATUS, to_char(START_TIME,'mm/dd/yy hh24:mi') start_time, to_char(END_TIME,'mm/dd/yy hh24:mi') end_time, elapsed_seconds/3600 hrs from V$RMAN_BACKUP_JOB_DETAILS order by session_key asc;


Below query is to check whether backup is waiting for tape.

SELECT p.SPID, sw.EVENT, sw.SECONDS_IN_WAIT AS SEC_WAIT,sw.STATE, s.CLIENT_INFO
FROM V$SESSION_WAIT sw, V$SESSION s, V$PROCESS p
WHERE sw.EVENT LIKE '%s%bt%'
AND s.SID=sw.SID
AND s.PADDR=p.ADDR
ORDER BY SEC_WAIT ASC;

+++++++++++FIND OUT THE RMAN BACKUP STATUS++++++++++++++++++++++++++++++


set pages 9999 lines 300
col status for a10
col object_type for a10

alter session set nls_date_format = 'DD-MM-YYYY HH24:MI:SS';

select SID,STATUS,START_TIME,END_TIME,OBJECT_TYPE,OUTPUT_DEVICE_TYPE from v$rman_status order by START_TIME asc;

select SID,STATUS,START_TIME,END_TIME,OBJECT_TYPE,OUTPUT_DEVICE_TYPE from v$rman_status  where status='RUNNING' order by START_TIME asc;

select SID,STATUS,START_TIME,END_TIME,OBJECT_TYPE,OUTPUT_DEVICE_TYPE from v$rman_status  where status='COMPLETED' order by START_TIME asc;

select SID,STATUS,START_TIME,END_TIME,OBJECT_TYPE,OUTPUT_DEVICE_TYPE from v$rman_status  where status='COMPLETED' and OBJECT_TYPE like '%FULL%' order by START_TIME asc;
***************************************************************************************************
 *******************SCN to timestamp *******************

col current_scn form 999999999999999999
col TIMESTAMP_TO_SCN form 9999999999999999
col NOW10G form 99999999999999999999
col NOW9I form 99999999999999999999
col SCN form 99999999999999999999
col TIMESTAMP form 99999999999999999999
alter session set NLS_DATE_FORMAT='DD-MON-YY HH:MI:SS';


select SCN_TO_TIMESTAMP(13223940424702) from dual;


select timestamp_to_scn( to_date('2012-01-30 04:00:00', 'YYYY-MM-DD HH24:MI:SS')) from dual ;
**********************restore restore status ********************************************'

set numwidth 20
SELECT sid, serial#, context, sofar, totalwork,
 round(sofar/totalwork*100,2) "% Complete"
 FROM v$session_longops
 WHERE opname LIKE 'RMAN%'
 AND opname NOT LIKE '%aggregate%'
 AND totalwork != 0
 AND sofar != totalwork;
 
 select device_type "Device", type, filename, to_char(open_time, 'mm/dd/yyyy hh24:mi:ss') open,
 to_char(close_time,'mm/dd/yyyy hh24:mi:ss') close,elapsed_time ET, effective_bytes_per_second EPS
 from v$backup_async_io;
 
 set line 190 pages 190
column FILENAME format a70
select sid,serial,filename,status,bytes/total_bytes*100 "Completed",EFFECTIVE_BYTES_PER_SECOND/1024/1024 "MB/S" from
V$BACKUP_ASYNC_IO where type = 'OUTPUT' order by status;
 
 

****************************************************************************************
rman_bkp.sh
********
#!/bin/sh
##. /home/oracle/.bash_profile
export DATE=$(date +%m%d%y_%H%M%S)
export ORACLE_SID=rvsprd01
export ORACLE_HOME=/opt/oracle/product/19.3.0
export PATH=/opt/oracle/product/19.3.0/bin:$PATH;
$ORACLE_HOME/bin/rman target / cmdfile=/upgrade/rman_rvsprd01/rman_bkp.cmd log=/upgrade/rman_rvsprd01/${DATE}_rvsprd01_BACKUP.log


rman.cmd
********
run
{
allocate channel c1 type DISK;
allocate channel c2 type DISK;
allocate channel c3 type DISK;
allocate channel c4 type DISK;
allocate channel c5 type DISK;
allocate channel c6 type DISK;
backup as compressed backupset incremental level 0 cumulative tag LEVEL0_BACKUP filesperset 4 format '/upgrade/rman_rvsprd01/%d_LVL0_%T_%s' database;
copy current controlfile to '/upgrade/rman_rvsprd01/%d_CTL_17082021';
release channel c1;
release channel c2;
release channel c3;
release channel c4;
release channel c5;
release channel c6;
}




To monitor job progress[RMAN]:
==============================

SELECT SID, SERIAL#, CONTEXT, SOFAR, TOTALWORK,ROUND (SOFAR/TOTALWORK*100, 2) "%_COMPLETE" FROM V$SESSION_LONGOPS 
WHERE OPNAME LIKE 'RMAN%'AND OPNAME NOT LIKE '%aggregate%' AND TOTALWORK != 0 AND SOFAR <> TOTALWORK; 

col status for a15
set linesize 200
col EVENT for a30
col program for a25
select a.sid,b.serial#, b.logon_time,b.status,a.state,a.seconds_in_wait,a.event,b.program,c.spid from v$session_wait a,v$session b, v$process c
where a.sid=b.sid and b.username = 'SYS' and b.PADDR = c.ADDR and b.program like '%rman%' order by 3;


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
************* Archive generation count ******************************
set linesize 140
set feedback off
set timing off
set pagesize 1000
col ARCHIVED format a8
col ins    format 99  heading "DB"
col member format a80
col status format a12
col archive_date format a20
col member format a60
col type   format a10
col group#  format 99999999
col min_archive_interval format a20
col max_archive_interval format a20
col h00 heading "H00" format  a3 
col h01 heading "H01" format  a3 
col h02 heading "H02" format  a3 
col h03 heading "H03" format  a3 
col h04 heading "H04" format  a3 
col h05 heading "H05" format  a3 
col h06 heading "H06" format  a3 
col h07 heading "H07" format  a3 
col h08 heading "H08" format  a3 
col h09 heading "H09" format  a3 
col h10 heading "H10" format  a3 
col h11 heading "H11" format  a3 
col h12 heading "H12" format  a3 
col h13 heading "H13" format  a3 
col h14 heading "H14" format  a3 
col h15 heading "H15" format  a3 
col h16 heading "H16" format  a3 
col h17 heading "H17" format  a3 
col h18 heading "H18" format  a3 
col h19 heading "H19" format  a3 
col h20 heading "H20" format  a3 
col h21 heading "H21" format  a3 
col h22 heading "H22" format  a3 
col h23 heading "H23" format  a3 
col total format a6
col date format a12
SELECT instance ins,
       log_date "DATE" ,
       lpad(to_char(NVL( COUNT( * ) , 0 )),6,' ') Total,
       lpad(to_char(NVL( SUM( decode( log_hour , '00' , 1 ) ) , 0 )),3,' ') h00 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '01' , 1 ) ) , 0 )),3,' ') h01 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '02' , 1 ) ) , 0 )),3,' ') h02 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '03' , 1 ) ) , 0 )),3,' ') h03 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '04' , 1 ) ) , 0 )),3,' ') h04 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '05' , 1 ) ) , 0 )),3,' ') h05 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '06' , 1 ) ) , 0 )),3,' ') h06 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '07' , 1 ) ) , 0 )),3,' ') h07 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '08' , 1 ) ) , 0 )),3,' ') h08 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '09' , 1 ) ) , 0 )),3,' ') h09 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '10' , 1 ) ) , 0 )),3,' ') h10 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '11' , 1 ) ) , 0 )),3,' ') h11 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '12' , 1 ) ) , 0 )),3,' ') h12 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '13' , 1 ) ) , 0 )),3,' ') h13 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '14' , 1 ) ) , 0 )),3,' ') h14 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '15' , 1 ) ) , 0 )),3,' ') h15 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '16' , 1 ) ) , 0 )),3,' ') h16 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '17' , 1 ) ) , 0 )),3,' ') h17 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '18' , 1 ) ) , 0 )),3,' ') h18 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '19' , 1 ) ) , 0 )),3,' ') h19 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '20' , 1 ) ) , 0 )),3,' ') h20 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '21' , 1 ) ) , 0 )),3,' ') h21 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '22' , 1 ) ) , 0 )),3,' ') h22 ,
       lpad(to_char(NVL( SUM( decode( log_hour , '23' , 1 ) ) , 0 )),3,' ') h23  
FROM   (
        SELECT thread# INSTANCE ,
               TO_CHAR( first_time , 'DD-MON-YY' ) log_date ,
               TO_CHAR( first_time , 'hh24' ) log_hour 
        FROM   v$log_history 
       ) 
GROUP  BY INSTANCE ,
       log_date 
ORDER  BY INSTANCE ,
       to_date(log_date,'DD-MON-YY'); 
       
**** Hourly basis *****   
       
select trunc(COMPLETION_TIME,'HH') Hour,thread# , 
round(sum(BLOCKS*BLOCK_SIZE)/1024/1024/1024) GB,
count(*) Archives from v$archived_log 
group by trunc(COMPLETION_TIME,'HH'),thread#  order by 1 ;

**** Hourly basis *****

set pages 1000
alter session set nls_date_format = 'DD-MON-YYYY HH24:MI:SS';

select trunc(COMPLETION_TIME,'HH') Hour,thread# , 
round(sum(BLOCKS*BLOCK_SIZE)/1024/1024/1024) GB,
count(*) Archives from v$archived_log 
group by trunc(COMPLETION_TIME,'HH'),thread#  order by 1 ;
***************************
set pages 1000
set lines 200
select trunc(COMPLETION_TIME,'DD') Day, thread#, round(sum(BLOCKS*BLOCK_SIZE)/1024/1024/1024) GB,count(*) Archives_Generated from v$archived_log
group by trunc(COMPLETION_TIME,'DD'),thread# order by 1;

*********************************	How to delete archive log file on Oracle RDS instance************************

select nvl(sum(BLOCKS * BLOCK_SIZE),0)/1024/1024/1024 GB from V$ARCHIVED_LOG  where DEST_ID=1 and ARCHIVED='YES' and DELETED='NO'; 

select * from V$ARCHIVED_LOG  where DEST_ID=1 and ARCHIVED='YES' and DELETED='NO';


    set serveroutput on
    exec rdsadmin.rdsadmin_util.show_configuration;

begin
    rdsadmin.rdsadmin_util.set_configuration
        (name  => 'archivelog retention hours',
        value => '24');
end;
/
commit;


EXEC rdsadmin.rdsadmin_util.switch_logfile;

select NAME,ARCHIVED,APPLIED,DELETED,STATUS,DICTIONARY_BEGIN,DICTIONARY_END from V$ARCHIVED_LOG;

***********************Highset table consuming space************
set lines 150
column owner format a10;
column table_name format a30;
column "SIZE (GB)" format 99999.99;
select * from (select owner, segment_name table_name, bytes/1024/1024/1024 "SIZE (GB)" from dba_segments where segment_type = 'TABLE' and segment_name not like 'BIN%' order by 3 desc)
where rownum <= 10;

**************Redo log scripts*************************
column REDOLOG_FILE_NAME format a50
SELECT  a.GROUP#, a.THREAD#, a.SEQUENCE#, a.ARCHIVED, a.STATUS, b.MEMBER AS REDOLOG_FILE_NAME, (a.BYTES/1024/1024) AS SIZE_MB FROM gv$log a JOIN gv$logfile b ON a.Group#=b.Group# ORDER BY a.GROUP#;

select lf.group#,l_type.log_type as type, lf.member from v$logfile lf join (select group#,'ORL' as log_type from v$log union select group#,'SRL' as log_type from v$standby_log) l_type on lf.group#=l_type.group#
order by lf.group#;

***********************************************************************
************* Flashback database to restore point*************

shutdown immediate;

startup mount;

flashback database to restore point <restorepoint_name>;

alter database open resetlogs;


****************restore time****************
set lines 200 pages 200
col OPNAME for a30
col TARGET for a30
col UNITS for a20
select INST_ID,SID,SERIAL#,OPNAME,TARGET,SOFAR,TOTALWORK,ROUND(SOFAR/TOTALWORK*100,2) " %_COMPLETE", TIME_REMAINING/3600 from gv$session_longops where time_remaining > 0 ;

************************************************************
************** restore point query **************

select * from v$restore_point;
drop restore point <restorepoint name>;

CREATE RESTORE POINT <restore point name> GUARANTEE FLASHBACK DATABASE;

*************** db_recovery_file_dest **********************

Select Substr(Name,1,40) name,
Space_Limit/1024/1024/1024 Space_Limit,
Space_Used/1024/1024/1024 Spce_Used,
Space_Reclaimable/1024/1024/1024 Space_Reclaimable,
Number_Of_Files Number_files
from V$RECOVERY_FILE_DEST;

SELECT Name ,
   ceil( space_limit / 1024 / 1024) SIZE_M,
   ceil( space_used  / 1024 / 1024) USED_M,
   ceil( space_reclaimable  / 1024 / 1024) RECLAIMABLE_M,
   decode( nvl( space_used, 0), 0, 0 , ceil ( ( ( space_used - space_reclaimable ) / space_limit) * 100) ) PCT_USED
FROM v$recovery_file_dest
ORDER BY name

SELECT GROUP_NUMBER,NAME,TOTAL_MB/1024,FREE_MB/1024,USABLE_FILE_MB/1024 FROM V$ASM_DISKGROUP;
  
  ADMINISTER KEY MANAGEMENT SET KEYSTORE  open identified by "gHe7UAJictqpz1Yj";

keystore altered.

SQL> alter database recover managed standby database using current logfile disconnect
  
  
**************************** dataguard related *************************
edit configuration set property CommunicationTimeout=300;

PRIAMRY:

select max(sequence#),thread# from gv$archived_log group by thread#;

SQL> SELECT THREAD#, LOW_SEQUENCE#, HIGH_SEQUENCE# FROM V$ARCHIVE_GAP;
no rows selected

Jay 
********

set linesize 200
column dest_name format a30
column destination format a30
column error format a20 wrap
select DEST_ID,DEST_NAME,STATUS,DESTINATION,DELAY_MINS,NET_TIMEOUT,DB_UNIQUE_NAME,ERROR from v$archive_dest;

************ See the difference of redo applied and recieved*****************
CONFIGURE ARCHIVELOG DELETION POLICY TO NONE; # default
 sh tail -20f ggserr.log

Standby Sync:

SELECT ARCH.THREAD# "Thread", ARCH.SEQUENCE# "Last Sequence Received", APPL.SEQUENCE# "Last Sequence Applied", (ARCH.SEQUENCE# - APPL.SEQUENCE#) "Difference"
FROM
(SELECT THREAD# ,SEQUENCE# FROM V$ARCHIVED_LOG WHERE (THREAD#,FIRST_TIME ) IN (SELECT THREAD#,MAX(FIRST_TIME) FROM V$ARCHIVED_LOG GROUP BY THREAD#)) ARCH,
(SELECT THREAD# ,SEQUENCE# FROM V$LOG_HISTORY WHERE (THREAD#,FIRST_TIME ) IN (SELECT THREAD#,MAX(FIRST_TIME) FROM V$LOG_HISTORY GROUP BY THREAD#)) APPL
WHERE ARCH.THREAD# = APPL.THREAD# ORDER BY 1;


select name, value, unit, time_computed from v$dataguard_stats where name in ('transport lag', 'apply lag');

select LOG_ARCHIVED-LOG_APPLIED "LOG_GAP" from
(SELECT MAX(SEQUENCE#) LOG_ARCHIVED
FROM V$ARCHIVED_LOG WHERE DEST_ID=1 AND ARCHIVED='YES'),
(SELECT MAX(SEQUENCE#) LOG_APPLIED
FROM V$ARCHIVED_LOG WHERE DEST_ID=2 AND APPLIED='YES');

********MRP process status*********

SELECT PROCESS, STATUS, THREAD#, SEQUENCE#, BLOCK#, BLOCKS, DELAY_MINS from v$managed_standby;

SELECT PROCESS, STATUS, THREAD#, SEQUENCE#, BLOCK#, BLOCKS, DELAY_MINS from v$managed_standby where PROCESS like 'MRP%';

select message from v$dataguard_status;

To copy missed archive log and register to standby

alter database register logfile '/a01/oradata/brmprfs1/arch/2_8785_961216599.dbf'

alter system set log_archive_dest_2='SERVICE=adgsys LGWR ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=pimsysdb1' scope= both sid='*';
*****************ADG BUILD********************

connect target sys/Intuit_123@mdmpds01
connect auxiliary sys/Intuit_123@mdmpds02
run
{
allocate channel a1 DEVICE TYPE DISK;
allocate channel a2 DEVICE TYPE DISK;
allocate channel a3 DEVICE TYPE DISK;
allocate channel a4 DEVICE TYPE DISK;
allocate channel a5 DEVICE TYPE DISK;
allocate channel a6 DEVICE TYPE DISK;
allocate channel a7 DEVICE TYPE DISK;
allocate channel a8 DEVICE TYPE DISK;
allocate channel a9 DEVICE TYPE DISK;
allocate channel a10 DEVICE TYPE DISK;
allocate channel a11 DEVICE TYPE DISK;
allocate channel a12 DEVICE TYPE DISK;
allocate channel a13 DEVICE TYPE DISK;
allocate channel a14 DEVICE TYPE DISK;
allocate channel a15 DEVICE TYPE DISK;
allocate channel a16 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux1 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux2 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux3 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux4 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux5 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux6 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux7 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux8 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux9 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux10 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux11 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux12 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux13 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux14 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux15 DEVICE TYPE DISK;
ALLOCATE AUXILIARY CHANNEL aux16 DEVICE TYPE DISK;
DUPLICATE TARGET DATABASE FOR STANDBY FROM ACTIVE DATABASE NOFILENAMECHECK dorecover;
}
*****************************************************************************************
DBSNMP 
password: pack3rsl0ststeelers

select
 b.group#, a.archived, a.status, b.status, b.member 
from
 v$log a, v$logfile b
where a.group#=b.group#
order by 1,2;

************************* RMAN*******************

delete noprompt force archivelog all completed before 'sysdate-1/4';
delete noprompt archivelog all completed before 'sysdate-2';


connect target /

crosscheck archivelog all;
crosscheck archivelog sequence 13 thread 2;

delete expired archivelog all;
delete expired datafilecopy all;

RMAN> delete noprompt archivelog from sequence 1554 until sequence 1775 ; 

delete force archivelog until sequence 364730 thread 1;
delete noprompt archivelog until sequence 20540 thread 2;

DELETE ARCHIVELOG LIKE '%' BACKED UP 1 TIMES TO DEVICE TYPE DISK;
delete archivelog until time 'sysdate-15';
delete noprompt archivelog until time 'sysdate-1';
delete force archivelog until time 'sysdate-3';
DELETE FORCE ARCHIVELOG ALL BACKED UP 1 TIMES to SBT_TAPE;
DELETE ARCHIVELOG ALL BACKED UP 1 TIMES to disk;

show all;
list backup;
report obsolete;
delete obsolete;
delete backup tag='BACKUP_PPPH2_00677_012015083128';

list backup summary completed before "sysdate -15";
delete noprompt backup completed before "sysdate -365";
list backup summary completed before "sysdate -8";

Standby:
CONFIGURE ARCHIVELOG DELETION POLICY TO BACKED UP 1 TIMES TO 'DISK' APPLIED ON ALL STANDBY;
CONFIGURE ARCHIVELOG DELETION POLICY TO APPLIED ON STANDBY;

Primary:
CONFIGURE ARCHIVELOG DELETION POLICY TO BACKED UP 1 TIMES TO 'SBT_TAPE' SHIPPED TO ALL STANDBY;


[oracle@xxxxxxxxxxx ~]$ cat crosscheck_and_delete_expired.rman
run
{
crosscheck backup;
crosscheck copy;
delete expired backup;
}

[oracle@xxxxxxxxxxx ~]$ mv OEMT1_crosscheck_and_delete_expired.log OEMT1_crosscheck_and_delete_expired.log_old
[oracle@xxxxxxxxxxx ~]$ . oraenv
ORACLE_SID = [xxxx] ? xxxxx
The Oracle base remains unchanged with value /u01/app/oracle
[oracle@xxxxxxxxxxx ~]$ rman target / cmdfile=crosscheck_and_delete_expired.rman log=crosscheck_and_delete_expired.log &


******How to restore archive logs*****
run
{
execute script allocate_archive_channel;
set archivelog destination to '/usr/local/oracle/archive/a';
restore archivelog from logseq 379924 until logseq 379930 thread 1;
execute script release_archive_channel;
}

*****************Pre-prod restore in intuit***********

run {
allocate channel dev1 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
allocate channel dev2 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
allocate channel dev3 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
allocate channel dev4 type sbt parms='SBT_LIBRARY=/l/cleversafe/libosbws.so,SBT_PARMS=(OSB_WS_PFILE=/l/cleversafe/osbws_qdc_k_ppd.ora)';
crosscheck backup;
restore archivelog from sequence 51578 until sequence 51600;
}



17106-17200
*************************************************************************
************* ADD candidate disk in disk group***************************

SELECT GROUP_NUMBER,NAME,TOTAL_MB/1024,FREE_MB/1024,USABLE_FILE_MB/1024 FROM V$ASM_DISKGROUP;
select GROUP_NUMBER,NAME,TOTAL_MB/1024 "Total_GB" ,FREE_MB/1024 "Free_GB",FREE_MB/TOTAL_MB*100 "% Free" from v$asm_diskgroup;

select d.group_number,g.NAME,d.header_status, count(*) disk_count,sum(os_mb/1024) total_gb from v$asm_disk d,V$ASM_DISKGROUP g where d.GROUP_NUMBER=g.GROUP_NUMBER group by d.group_number,g.NAME,d.header_status;

select path,os_mb/1024,header_Status from v$asm_Disk where header_Status!='MEMBER';

select group_number, path, header_status,os_mb/1024 from v$asm_disk order by 1;

alter diskgroup DATA01 add disk '/dev/oradisk/ASM/new_asm_vol28' rebalance power 4;

alter diskgroup RECOVER01 drop disk RECOVER01_0002;

alter diskgroup DATA01 rebalance power 10;
select * from v$asm_operation;

SELECT group_number, operation, state, power, est_minutes FROM v$asm_operation;

*********IMBALANCE******

SELECT g.name "Diskgroup",
    100*(max((d.total_mb-d.free_mb)/d.total_mb)-min((d.total_mb-d.free_mb)/d.total_mb))/max((d.total_mb-d.free_mb)/d.total_mb) "Imbalance",
    100*(max(d.total_mb)-min(d.total_mb))/max(d.total_mb) "Variance",
    100*(min(d.free_mb/d.total_mb)) "MinFree",
    count(*) "DiskCnt",
    g.type "Type"
    FROM v$asm_disk d, v$asm_diskgroup g
    WHERE d.group_number = g.group_number and
    d.group_number <> 0 and
    d.state = 'NORMAL' and
    d.mount_status = 'CACHED'
    GROUP BY g.name, g.type;

*******************************************************************
*********** How to remove running trace files***************

select pid, program from v$process where program like '%ora%';

oradebug setorapid 16

!mv /usr/local/oracle/log/diag/asm/+asm/+ASM2/trace/+ASM2_rbal_28646.trc /usr/local/oracle/log/diag/asm/+asm/+ASM2/trace/+ASM2_rbal_28646.trc_old
!mv /usr/local/oracle/log/diag/asm/+asm/+ASM2/trace/+ASM2_rbal_28646.trm /usr/local/oracle/log/diag/asm/+asm/+ASM2/trace/+ASM2_rbal_28646.trm_old

oradebug close_trace

***********************************************************************
************** Flush shared pool**************************************

SELECT POOL,NAME, ROUND(BYTES/1024/1024,2) FREE_MB 
FROM V$SGASTAT 
WHERE POOL='shared pool' AND NAME='free memory' ORDER BY BYTES DESC;

alter system flush shared_pool;

col value for 999,999,999,999 heading “Shared Pool Size”
col bytes for 999,999,999,999 heading “Free Bytes”
select to_number(v$parameter.value) value, v$sgastat.bytes,
(v$sgastat.bytes/v$parameter.value)*100 "Percent Free"
from v$sgastat, v$parameter
where v$sgastat.name = 'free memory'
and v$parameter.name = 'shared_pool_size';

************************************************************************
********************** RMAN COLD BACKUP ************************
===========

shutdown immediate

startup mount

BACKUP DATABASE FORMAT "/usr/local/oracle/exports/devplx01_coldbackup_%U";  

Archives deletaton based on time.
**********************************



select sysdate - interval '3' hour from dual

DELETE archivelog until time "to_date('21-09-2018:11:11:01','DD-MM-YYYY:hh24:mi:ss')";

************************ CRSCTL and SRVCTL commands **********************
crsctl check has
crsctl stop has
crsctl start has
crsctl status resource -t

** How to start OCSSD manually ************
./crsctl start res ora.cssd -init -env "CSSD_MODE=-X"


crd_stat
srvctl status scan_listener

$ srvctl status scan_listener -i 3
SCAN Listener LISTENER_SCAN3 is enabled
SCAN listener LISTENER_SCAN3 is running on node uecdb01

srvctl relocate scan_LISTENER -i 3 -n uecdb03
srvctl relocate scan_LISTENER -i 1 -n uecdb01

srvctl status Fsql ce -d <database name>         PRDCDI

srvctl status instance -d <database name> -i <instance name>

Check for prefered node
srvctl config service -d <db name> -s <service name>

crsctl status resource -t


If we don't know database name but know service name 
crsctl status resource -t  | grep -i <service name>


srvctl -h|grep service

crs_stat | awk -F= '/NAME=/{n=$2}/TYPE=/{t=$2}/TARGET=/{g=$2}/STATE=/{s=$2; printf("%-75s%-18s%-15s%-30s\n", n,t,g,s)}'



******* How to relocate services and bring down database, ASM and clusterware (DB version 11.1...) ********

srvctl status service -d PRDREF
srvctl relocate service -d PRDREF -s prdref_batch -i prdref2 -t prdref1 -f
srvctl relocate service -d PRDREF -s prdrefloy -i prdref2 -t prdref1 -f
srvctl status service -d PRDREF

srvctl status database -d PRDREF
srvctl status instance -d PRDREF -i prdref2
srvctl stop instance -d PRDREF -i prdref2

srvctl status asm -n pcdidb05
srvctl stop asm -n pcdidb05

srvctl status nodeapps -n pcdidb05
srvctl stop nodeapps -n pcdidb05

Stop the listener and agent from the node(pcdidb05):- As root user
cd /usr/local/crs/11.1.0/bin/
./crsctl check crs
./crsctl stop crs
****************** Checking previleges ****************************

SQL> select GRANTEE,TABLE_NAME,OWNER,PRIVILEGE from dba_tab_privs where TABLE_NAME='POWER_WORK_ITEM' and GRANTEE='PWR_PERFTEST_APP';

GRANTEE                        TABLE_NAME                     OWNER                          PRIVILEGE
------------------------------ ------------------------------ ------------------------------ ----------------------------------------
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_SYSTEST_OWNER              DELETE
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_SYSTEST_OWNER              SELECT
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_SYSTEST_OWNER              UPDATE
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_PERFTEST_OWNER             DELETE
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_PERFTEST_OWNER             INSERT
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_PERFTEST_OWNER             SELECT
PWR_PERFTEST_APP               POWER_WORK_ITEM                PWR_PERFTEST_OWNER             UPDATE

SQL> select * from dba_synonyms where table_name='POWER_WORK_ITEM' and owner='PWR_PERFTEST_APP';

OWNER              SYNONYM_NAME    TABLE_OWNER          TABLE_NAME                     DB_LINK
------------------ --------------- -------------------- ------------------------------ ------------------------------
PWR_PERFTEST_APP   POWER_WORK_ITEM PWR_SYSTEST_OWNER    POWER_WORK_ITEM



********************* REFRESH POWER database *******************
Schema credentials: /usr/local/oracle/etc/oracle_schema.pwd

SQL> show user
USER is "PWR_SNAP"
SQL> exec dbms_mview.refresh('OEOWNER.ORDER_EXCEPTION_MV','C');

PL/SQL procedure successfully completed.

SQL> exec dbms_mview.refresh('OEOWNER.ORDER_EXCEPTION_MV','F');

PL/SQL procedure successfully completed.

Check the mview status.
column last_refresh_type format a25
column owner format a20
column mview_name format a35
select owner, mview_name, last_refresh_type, last_refresh_date from dba_mviews order by last_refresh_date;
 
exec dbms_mview.refresh( 'ORDER_EXCEPTION_MV', 'F' );
exec dbms_mview.refresh( 'ARACSLOG_HRLY', 'C' );
exec dbms_mview.refresh( 'ARESLOG_HRLY', 'C' );

execute dbms_mview.refresh('ORDER_EXCEPTION_MV','f');

EXEC DBMS_MVIEW.refresh('ORDER_EXCEPTION_MV');

mview refresh schedule

CREATE OR REPLACE PROCEDURE refresh_mv_proc1 AS
BEGIN
    DBMS_MVIEW.REFRESH('PIM_FVROLLUP_MV_TEMP', 'C');
END;
/

BEGIN
    DBMS_SCHEDULER.create_job (
        job_name        => 'refresh_mv_job1',
        job_type        => 'PLSQL_BLOCK',
        job_action      => 'BEGIN refresh_mv_proc1; END;',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=HOURLY',
        enabled         => TRUE
    );
END;
/


set heading off
set echo off
set flush off
set pagesize 9999
set linesize 9999
set long 9999

select dbms_metadata.get_ddl('MATERIALIZED_VIEW','BO_RPT_SMART_PART_MV','FOS') from dual ;


select dbms_metadata.get_ddl('PACKAGE','ENGPKIMP','APPS') from dual ;



SET LINES 999 PAGES 333
col TO_CHAR(A.ELAPSED_TIME) for a30
col ELAPSED_TIME for a20
COL MVIEW_NAME FOR A30
COL MV_OWNER FOR A15
col END_TIME for a30
COL MV_NAME FOR A30
COL REFRESH_METHOD FOR A20
COL START_TIME FOR A40
COL ELAPSED_TIME FOR A30
col LAST_REFRESH_DATE for a30

SELECT A.MV_OWNER, A.MV_NAME, B.LAST_REFRESH_DATE , A.START_TIME,A.END_TIME, TO_CHAR(A.ELAPSED_TIME), B.STALENESS, B.STALE_SINCE  FROM DBA_MVREF_STATS A, DBA_MVIEWS B   WHERE A.MV_NAME='BO_PROD_ATTRIBS_MV'
AND 
A.MV_OWNER='FOS'
AND
A.MV_NAME=B.MVIEW_NAME
AND
A.MV_OWNER=B.OWNER ORDER BY A.START_TIME DESC FETCH NEXT 10 ROWS ONLY;


*****ICPLUS********
Password location: /usr/local/oracle/etc/license_icplus0_pw

To check job name:

col JOB_ACTION form a30
col SCHEDULE_NAME form a20
COL OWNER FORM A10
select
-- owner,
owner, job_name, enabled, schedule_name, job_type, job_action,
-- RUN_COUNT run_cnt,
-- FAILURE_COUNT fail_cnt,
to_char(LAST_START_DATE,'mm-dd-yy hh24:mi:ss') LAST_START_DATE,
to_char(NEXT_RUN_DATE,'mm-dd-yy hh24:mi:ss') NEXT_RUN_DATE
from DBA_SCHEDULER_JOBS where job_name like '%STATS%';
where job_name like 'MV_RF$J_0_S_23132%'
      and owner not in ('SYS','SYSTEM');

OWNER      JOB_NAME                       ENABL SCHEDULE_NAME        JOB_TYPE         JOB_ACTION                     LAST_START_DATE   NEXT_RUN_DATE
---------- ------------------------------ ----- -------------------- ---------------- ------------------------------ ----------------- -----------------
ICPLUS_0   MV_JOB_NCPDP_DATA_FMT          TRUE  EVERY_1_HOUR         STORED_PROCEDURE MV_PROC_NCPDP_DATA_FMT         11-10-14 09:14:38 11-10-14 10:14:37
ICPLUS_0   MV_JOB_PBR_THRD_PTY            TRUE  EVERY_6_HOUR         STORED_PROCEDURE MV_PROC_PBR_THRD_PTY           11-10-14 05:14:37 11-10-14 11:14:37
ICPLUS_0   MV_JOB_PLAN_DRUG_COVERAGE      TRUE  EVERY_6_HOUR         STORED_PROCEDURE MV_PROC_PLAN_DRUG_COVERAGE     11-10-14 05:14:37 11-10-14 11:14:37
ICPLUS_0   MV_JOB_PRESCRIBER_NTIS         TRUE  EVERY_6_HOUR         STORED_PROCEDURE MV_PROC_PRESCRIBER_NTIS        11-10-14 05:14:37 11-10-14 11:14:37
ICPLUS_0   MV_JOB_PRESCRIBER              TRUE  EVERY_30_SECOND      STORED_PROCEDURE MV_PROC_PRESCRIBER             11-10-14 09:22:06 11-10-14 09:11:54
ICPLUS_0   MV_JOB_PWR_STORE               TRUE  EVERY_15_MINUTE      STORED_PROCEDURE MV_PROC_PWR_STORE              11-10-14 09:14:37 11-10-14 09:29:37
ICPLUS_0   MV_JOB_REH_TPR_CD_MAPPING      TRUE  EVERY_1_HOUR         STORED_PROCEDURE MV_PROC_REH_TPR_CD_MAPPING     11-10-14 09:14:37 11-10-14 10:14:37
ICPLUS_0   MV_JOB_REH_TPR_ROUTING         TRUE  EVERY_1_HOUR         STORED_PROCEDURE MV_PROC_REH_TPR_ROUTING        11-10-14 09:14:37 11-10-14 10:14:37
ICPLUS_0   MV_JOB_STATE_LABEL_RQMT        TRUE  EVERY_1_HOUR         STORED_PROCEDURE MV_PROC_STATE_LABEL_RQMT       11-10-14 09:14:37 11-10-14 10:14:37
ICPLUS_0   MV_JOB_RXC_PLAN                TRUE  EVERY_8_HOUR         STORED_PROCEDURE MV_PROC_RXC_PLAN               11-10-14 09:14:37 11-10-14 17:14:37
ICPLUS_0   MV_JOB_CODE_DTL                TRUE  EVERY_6_HOUR         STORED_PROCEDURE MV_PROC_CODE_DTL               11-10-14 05:14:37 11-10-14 11:14:37


To check DDL from proc (job action)
	  
select text from dba_source where OWNER='SYS' and NAME='MAINTENANCE_WINDOW_GROUP' /*Job_Action from dba_scheduler_jobs*/ ;

select dbms_metadata.get_ddl('MVIEW','BO_PROD_ATTRIBS_MV','FOS') from dual; 


select dbms_metadata.get_ddl('TABLE','EGO_MTL_SY_ITEMS_EXT_B','EGO') from dual; 
**** Check for snap and use the same in refresh*******

SQL> conn ICPLUS_0/idah0p0tat0
Connected.

exec dbms_mview.refresh('ICPLUS_0.TBF0_PRESCRIBER_NTIS_SNAP','C');

exec dbms_mview.refresh('ICPLUS_0.TBF0_PRESCRIBER_NTIS_SNAP','F');


SELECT owner, mview_name, last_refresh_date FROM dba_mviews;


CREATE MATERIALIZED VIEW LOG ON "SECS7"."ARACSLOG" PCTFREE 10 PCTUSED 30 INITRANS 1 MAXTRANS 255 LOGGING STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 
MAXEXTENTS 2147483645 PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) TABLESPACE "S7_MV_DATA"
WITH ROWID ( "BANKID", "PAREQTIME", "PARESSTATUS", "RANGEID", "TXTYPE" ) INCLUDING NEW VALUES;



select owner, mview_name, last_refresh_type, last_refresh_date from dba_mviews order by owner ;



Matirilized views

col owner for a10
col mview_name for a30
col last_refresh_type for a20
col last_refresh_date for a40
select owner, mview_name, last_refresh_type, last_refresh_date from dba_mviews order by last_refresh_date ; 
 
 *************************************************
 ************AWR Report SANP ID's Query Tunning*********
 
 select ss.snap_id,
ss.instance_number node,
begin_interval_time,
sql_id,
plan_hash_value,
nvl(executions_delta,0) execs,
round((elapsed_time_delta/decode(nvl(executions_delta,0),0,1,executions_delta))/1000000,2) avg_etime,
round((buffer_gets_delta/decode(nvl(buffer_gets_delta,0),0,1,executions_delta)),2) avg_lio
from DBA_HIST_SQLSTAT S,
DBA_HIST_SNAPSHOT SS
where sql_id = 'ft6wvcds5bddn'
and ss.snap_id = S.snap_id
and ss.instance_number = S.instance_number
and executions_delta > 0
order by 1 desc, 2, 3;


**************** USER management **************************************

select OWNER,TRIGGER_NAME,STATUS from dba_triggers where TRIGGER_NAME like '%DROP%';

ALTER TRIGGER TR_USER_NODROP DISABLE;

ALTER TRIGGER TR_USER_NODROP ENABLE;



*********** How to open a database is archive log mode **************

SQL> select name,open_mode,log_mode from v$database;

NAME      OPEN_MODE            LOG_MODE
--------- -------------------- ------------
DEVSRX01  READ WRITE           NOARCHIVELOG

SQL> select DEST_NAME,STATUS,DESTINATION from V$ARCHIVE_DEST;

DEST_NAME                      STATUS    DESTINATION
------------------------------ --------- ------------------------------------------------------------
LOG_ARCHIVE_DEST_1             VALID     /usr/local/oracle/product/11.2.0/dbhome_1/dbs/arch
LOG_ARCHIVE_DEST_2             INACTIVE
LOG_ARCHIVE_DEST_3             INACTIVE
LOG_ARCHIVE_DEST_4             INACTIVE
LOG_ARCHIVE_DEST_5             INACTIVE

SQL> show parameter backup_tape_io_slaves

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
backup_tape_io_slaves                boolean     FALSE


alter system set LOG_ARCHIVE_DEST_1='LOCATION=/usr/local/oracle/archive/c' scope=both;

Shutdown immediate;

startup mount;

alter database archivelog;

alter database open;

********************************************************************

ORA-04021: timeout occurred while waiting to lock object

Basically, whilst someone or something else (a scheduled job perhaps?) is executing the package, then you won’t be able to perform the recompile.  To get around this, you need to identify the locking session and kill it.

BREAK ON sid ON lock_id1 ON kill_sid

COL sid            FOR 999999
COL lock_type      FOR A38
COL mode_held      FOR A12
COL mode_requested FOR A12
COL lock_id1       FOR A20
COL lock_id2       FOR A20
COL kill_sid       FOR A50

SELECT s.sid,
       l.lock_type,
       l.mode_held,
       l.mode_requested,
       l.lock_id1,
       'alter system kill session '''|| s.sid|| ','|| s.serial#|| ''' immediate;' kill_sid
FROM   dba_lock_internal l,
       v$session s
WHERE  s.sid = l.session_id
AND    UPPER(l.lock_id1) LIKE '%&package_name%'
AND    l.lock_type = 'Body Definition Lock'
/

    SID LOCK_TYPE                              MODE_HELD    MODE_REQUEST LOCK_ID1             KILL_SID
------- -------------------------------------- ------------ ------------ -------------------- --------------------------------------------------
    218 Body Definition Lock                   Null         None         USER2.TEST_PACKAGE   alter system kill session '218,12455' immediate;
	
	
NOTE: If your dba_lock_internal view doesn’t exist, you can create this by running: $ORACLE_HOME/rdbms/admin/catblock.sql

Check out what the offending session is doing:

BREAK ON sid ON username ON osuser ON os_pid ON program
10.69.30.24
SELECT s.sid,
       NVL(s.username, 'ORACLE PROC') username,
       s.osuser,
       p.spid os_pid,
       s.program,
       t.sql_text
FROM   v$session s,
       v$sqltext t,
       v$process p
WHERE  s.sql_hash_value = t.hash_value
AND    s.paddr = p.addr
AND    s.sid = &session_id
AND    t.piece = 0 -- optional to list just the first line
ORDER BY s.sid, t.hash_value, t.piece
/

SID   USERNAME     OSUSER       OS_PID     PROGRAM               SQL_TEXT
----- ------------ ------------ ---------- --------------------- --------------------------------------------------------------
218   USER2        oracle       8023       oracle@linux01 (J001) DECLARE job BINARY_INTEGER := :job; next_date DATE := :mydate;

********************* Drop database **********************

1.Shutdown immediate.
2.Startup mount exclusive restrict.
3.drop database

Drop database command should remove databases files,controlfiles,alert log


******** How to export statistics of a locked table ***********

Step 1: Check for locked statistics
select owner,table_name,stattype_locked from dba_tab_statistics where owner=<owner name> and stattype_locked='ALL' order by 1;

Step 2: Unlock table stats
exec dbms_stats.unlock_table_stats('OWNER','TABLE_NAME');

Step 3: Create stattab ****** table where we export stats******
exec dbms_stats.create_stat_table(ownname => 'OWNER_NAME', stattab =>'STATTAB_NAME', tblspace => 'TBS_NAME');

Step 4: Export table stats to the stattab
exec dbms_stats.export_table_stats(ownname=>'OWNER_NAME', tabname => 'TABLE_NAME', stattab =>'STATTAB_NAME',cascade=>true);

Step 5: Lock table stats
exec dbms_stats.lock_table_stats('OWNER_NAME','TABLE_NAME');

Step 1: Verify locked statistics
select owner,table_name,stattype_locked from dba_tab_statistics where owner=<owner name> and stattype_locked='ALL' order by 1;

****************************************************************

For Hanganalyze: 

sqlplus '/ as sysdba' 
oradebug setmypid 
oradebug unlimit 
oradebug hanganalyze 3 
-- Wait one minute before getting the second hanganalyze 
oradebug hanganalyze 3 
-- Wait one minute before getting the third hanganalyze 
oradebug hanganalyze 3 
oradebug tracefile_name 
exit 

For Systemstate dump: 

sqlplus '/ as sysdba' 
oradebug setmypid 
oradebug unlimit 
oradebug dump systemstate 266 
oradebug dump systemstate 266 
oradebug tracefile_name 
exit 

*****************************************************************
*****SQL tuning adviser ********

set serveroutput on
declare
  l_sql_tune_task_id  varchar2(100);
begin
  l_sql_tune_task_id := dbms_sqltune.create_tuning_task (
                          sql_id      => '6zmr1syjpr42t',
                          scope       => dbms_sqltune.scope_comprehensive,
                          time_limit  => 60,
                          task_name   => 'test_2',
                          description => 'tuning task for statement your_sql_id.');
  dbms_output.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);
end;
/


exec dbms_sqltune.execute_tuning_task(task_name => 'test_2');

-- displaying the recommendations
set long 100000;
set longchunksize 1000
set pagesize 10000
set linesize 100
select dbms_sqltune.report_tuning_task('test_2') as recommendations from dual;​

*************************************
*** SQL monitoring report ***********

SET LONG 1000000
SET LONGCHUNKSIZE 1000000
SET LINESIZE 1000
SET PAGESIZE 0
SET TRIM ON
SET TRIMSPOOL ON
SET ECHO OFF
SET FEEDBACK OFF

SPOOL /tmp/sql_monitor_8pyztx5g69btg.html

SELECT DBMS_SQLTUNE.report_sql_monitor(
  sql_id => '8pyztx5g69btg',
  type => 'HTML',
  report_level => 'ALL') AS report
FROM dual;

spool off

*****************************

**************IDRMS**************

set long 100000
set head off
set echo off
set pagesize 0
set verify off
SELECT dbms_metadata.get_ddl('USER','&&uname') FROM dual;


********** How to see Hidden parameters ***********

SET PAUSE ON
SET PAUSE 'Press Return to Continue'
SET PAGESIZE 60
SET LINESIZE 300
COLUMN ksppinm FORMAT A50
COLUMN ksppstvl FORMAT A50
COLUMN ksppstvl FORMAT A50
SELECT
  ksppinm,
  ksppstvl
FROM
  x$ksppi a,
  x$ksppsv b
WHERE
  a.indx=b.indx 
AND
  substr(ksppinm,1,1) = '_'
ORDER BY ksppinm
/


************* EXPDP IMPDP Export Import****************

SQL> create directory EXPORT as '/data/pdsrefresh_22';  

Directory created. 

SQL> grant read,write on directory EXPORT to system;

Grant succeeded.

vi expdp.par

userid='/as sysdba' 
directory=EXPDP 
dumpfile=expdp_full_%U.dmp
logfile=expdp_full.log 
tables=INIAPP10.APPDEPLOYMENT,INIAPP10.APPINSTANCE,INIAPP10.CONFIGELEMENT
Flashback_scn=12653201173911


USERID='/ as sysdba'
TABLES=LPD_DASHBD_OWNER.STG_CV_TXN_RTRN_DTL
REMAP_SCHEMA=LPD_DASHBD_OWNER:LPD_AB_TEST
directory=REFRESH_DIR
DUMPFILE=expdp_tables.dmp
LOGFILE=impdp_tables_test1.log

select property_value from database_properties where property_name like '%DEFAULT_TEMP_TABLESPACE%';

userid='/ as sysdba'
DIRECTORY=EXP_DIR
DUMPFILE=FACTOPS-4280_BRM104_01_%U.dmp
logfile=imp_FACTOPS-4280_BRM01_01.log
remap_tablepace=PINX00:PINX00
REMAP_TABLESPACE=PIN00:PIN00
REMAP_SCHEMA=brm104_01:brm01_01

FILESIZE=20G
parallel=4
schemas=<schema1>,<schema2>
CONTENT=DATA_ONLY

userid='/ as sysdba'
Directory=IMPDP_SCHEMA
DUMPFILE=expdp_Schema_PPHRX_PEOPLE_PPH1_OWNER_%U.dmp
logfile=IMPDP_Schema_PPHRX_PEOPLE_PPH1_OWNER.log
table_exists_action=truncate
parallel=4
schemas=PPHRX_OWNER,PEOPLE_OWNER,PPH1_OWNER


impdp sys/password@pdb1 as sysdba \
    FULL=Y \
    DUMPFILE=full_exp_dump.dmp \
    DIRECTORY=DATA_PUMP_DIR \
    LOGFILE=full_datapump_import.log \
    PARALLEL=4


*************In AWS*****************

DECLARE
hdnl NUMBER;
BEGIN
hdnl := DBMS_DATAPUMP.OPEN( operation => 'EXPORT', job_mode => 'SCHEMA', job_name=>null);
DBMS_DATAPUMP.ADD_FILE( handle => hdnl, filename => 'ersperfstage_item30%U.dmp', directory => 'DATA_PUMP_DIR', filetype => dbms_datapump.ku$_file_type_dump_file);
DBMS_DATAPUMP.ADD_FILE( handle => hdnl, filename => 'ersperfstage_item30.log', directory => 'DATA_PUMP_DIR', filetype => dbms_datapump.ku$_file_type_log_file);
DBMS_DATAPUMP.METADATA_FILTER(hdnl,'SCHEMA_EXPR','IN(''ITEM30'',''ERSTOOLS'')');
DBMS_DATAPUMP.set_parallel(handle => hdnl, degree => 3);
dbms_datapump.set_parameter(handle => hdnl, name => 'COMPRESSION', value => 'ALL'); 
DBMS_DATAPUMP.set_parameter(handle => hdnl, name => 'FLASHBACK_SCN', value => 78796990);
DBMS_DATAPUMP.START_JOB(hdnl);
END;
/



SELECT text FROM table(rdsadmin.rds_file_util.read_text_file('DATA_PUMP_DIR','impdp_mdmpds11g_PARTYREF_rds.log'));

SELECT rdsadmin.rdsadmin_s3_tasks.upload_to_s3(
      p_bucket_name    =>  'backup-10142020', 
      p_prefix         =>  'cwallet.sso', 
      p_s3_prefix      =>  '', 
      p_directory_name =>  'WALLET_DIR') 
   AS TASK_ID FROM DUAL; 


    SELECT text FROM table(rdsadmin.rds_file_util.read_text_file('BDUMP','dbtask-1742320279925-950.log')); 


SELECT rdsadmin.rdsadmin_s3_tasks.download_from_s3(
      p_bucket_name    =>  'crmsys-datapump', 
      p_s3_prefix      =>  'expdp_CX_CORRESP', 
      p_directory_name =>  'DATA_PUMP_DIR') 
   AS TASK_ID FROM DUAL; 
   
   
SELECT rdsadmin.rdsadmin_s3_tasks.download_from_s3(
  p_bucket_name    =>  'aws-rvs-backups',
  p_s3_prefix      =>  'expdp_XXINT_606_RECON_BY_SKU', 
  p_directory_name =>  'DATA_PUMP_DIR')
AS TASK_ID FROM DUAL;


SELECT text FROM table(rdsadmin.rds_file_util.read_text_file('BDUMP','dbtask-1742420828570-50.log'));  

06) To find the dump files in the RDS instance.
select * from table(RDSADMIN.RDS_FILE_UTIL.LISTDIR('DATA_PUMP_DIR'))order by mtime;


exec utl_file.fremove('S3_WALLET','cwallet.sso');


DECLARE
hdnl NUMBER;
BEGIN
hdnl := DBMS_DATAPUMP.OPEN( operation => 'IMPORT', job_mode => 'SCHEMA', job_name=>null);
dbms_output.put_line(hdnl);
DBMS_DATAPUMP.ADD_FILE( handle => hdnl, filename => 'ersperfstage_item30%U.dmp', directory => 'DATA_PUMP_DIR', filetype => dbms_datapump.ku$_file_type_dump_file);
DBMS_DATAPUMP.ADD_FILE( handle => hdnl, filename => 'imp_ersperfstage_item30.log', directory => 'DATA_PUMP_DIR', filetype => dbms_datapump.ku$_file_type_log_file);
DBMS_DATAPUMP.SET_PARAMETER(hdnl,'TABLE_EXISTS_ACTION','REPLACE');
DBMS_DATAPUMP.metadata_transform ( hdnl, 'OID' , 0 , null ) ;
DBMS_DATAPUMP.set_parallel(handle => hdnl, degree => 3);
DBMS_DATAPUMP.START_JOB(hdnl);
END;
/

***

DECLARE
hdnl NUMBER;
BEGIN
hdnl := DBMS_DATAPUMP.OPEN( operation => 'IMPORT', job_mode => 'SCHEMA', job_name=>null);
dbms_output.put_line(hdnl);
DBMS_DATAPUMP.ADD_FILE( handle => hdnl, filename => 'cassys_preprod_17sep19_%U.dmp', directory => 'DATA_PUMP_DIR', filetype => dbms_datapump.ku$_file_type_dump_file);
DBMS_DATAPUMP.METADATA_REMAP (handle => hdnl,name => 'REMAP_TABLESPACE',old_value => 'ACCOUNT_TDE',value => 'ACCOUNT');
DBMS_DATAPUMP.METADATA_REMAP (handle => hdnl,name => 'REMAP_TABLESPACE',old_value => 'BILLING_TDE',value => 'BILLING');
DBMS_DATAPUMP.METADATA_REMAP (handle => hdnl,name => 'REMAP_TABLESPACE',old_value => 'ORDERS_TDE',value => 'ORDERS');
DBMS_DATAPUMP.ADD_FILE( handle => hdnl, filename => 'import_files.log', directory => 'DATA_PUMP_DIR', filetype => dbms_datapump.ku$_file_type_log_file);
DBMS_DATAPUMP.METADATA_FILTER(hdnl,'SCHEMA_EXPR','IN (''DATA_GOVERNANCE'',''IDSOWN'',''IDSAPP'',''NEWEISE2E'',''EDSAPP'',''EDSOWN'',''PDSAPP'',''PDSOWN'',''ADSAPP'',''ADSOWN'',''MAP'',''MDM'',''BILLING'',''ASSET'',''ORDERS'',''CATALOG'',
''ACCOUNT'',''APPSEC'',''DGDEV'',''DGAPP'',''IAC_APP_SELECT'',''COMMUSER'',''READONLY'',''MAPAPP'',''EISP_READONLY'',''KVELHAL'',''EBS_IQUATE_PPD'',''SBIGGIE'','’PMERRINER'')');
DBMS_DATAPUMP.set_parallel(handle=>hdnl,degree=>10);
DBMS_DATAPUMP.SET_PARAMETER(handle=>hdnl,name =>'TABLE_EXISTS_ACTION',value => 'REPLACE');
DBMS_DATAPUMP.START_JOB(hdnl);
END;
/

****

DECLARE
hdnl NUMBER;
BEGIN
hdnl := DBMS_DATAPUMP.OPEN( operation => 'IMPORT', job_mode => 'SCHEMA', job_name=>null);
dbms_output.put_line(hdnl);
DBMS_DATAPUMP.ADD_FILE( handle => hdnl, filename => 'expdp_FACTOPS_4682_%U.dmp', directory => 'DATA_PUMP_DIR', filetype => dbms_datapump.ku$_file_type_dump_file);
DBMS_DATAPUMP.METADATA_REMAP (handle => hdnl,name => 'REMAP_TABLESPACE',old_value => 'WEBSDATA',value => 'WEBSDATA');
DBMS_DATAPUMP.METADATA_REMAP (handle => hdnl,name => 'REMAP_TABLESPACE',old_value => 'WEBSITEM',value => 'WEBSITEM');
DBMS_DATAPUMP.METADATA_REMAP (handle => hdnl,name => 'REMAP_TABLESPACE',old_value => 'WEBSMIG',value => 'WEBSMIG');
DBMS_DATAPUMP.ADD_FILE( handle => hdnl, filename => 'impdp_FACTOPS_4682_1.log', directory => 'DATA_PUMP_DIR', filetype => dbms_datapump.ku$_file_type_log_file);
DBMS_DATAPUMP.METADATA_REMAP (handle => hdnl,name => 'REMAP_SCHEMA',old_value => 'WEBS',value => 'WEBS');
DBMS_DATAPUMP.METADATA_REMAP (handle => hdnl,name => 'REMAP_SCHEMA',old_value => 'WEBSITEM',value => 'WEBSITEM');
DBMS_DATAPUMP.METADATA_REMAP (handle => hdnl,name => 'REMAP_SCHEMA',old_value => 'WEBSMIG',value => 'WEBSMIG');
DBMS_DATAPUMP.set_parallel(handle=>hdnl,degree=>10);
DBMS_DATAPUMP.SET_PARAMETER(handle=>hdnl,name =>'TABLE_EXISTS_ACTION',value => 'REPLACE');
DBMS_DATAPUMP.START_JOB(hdnl);
END;
/

DECLARE
hdnl NUMBER;
BEGIN
hdnl := DBMS_DATAPUMP.OPEN( operation => 'EXPORT', job_mode => 'TABLE', job_name=>null);
DBMS_DATAPUMP.ADD_FILE( handle => hdnl, filename => 'expdp_XXINT_606_RECON_BY_SKU.dmp', directory => 'DATA_PUMP_DIR', filetype => dbms_datapump.ku$_file_type_dump_file);
DBMS_DATAPUMP.ADD_FILE( handle => hdnl, filename => 'expdp_XXINT_606_RECON_BY_SKU..log', directory => 'DATA_PUMP_DIR', filetype => dbms_datapump.ku$_file_type_log_file);
dbms_datapump.set_parameter(handle => hdnl, name => 'COMPRESSION', value => 'ALL');
DBMS_DATAPUMP.METADATA_FILTER(hdnl,'SCHEMA_EXPR','IN (''XXRS'')');
DBMS_DATAPUMP.METADATA_FILTER(hdnl,'NAME_EXPR','IN (''XXINT_606_RECON_BY_SKU'')');
dbms_datapump.set_parameter(handle => hdnl, name => 'FLASHBACK_SCN', value => 13181530798581); 
DBMS_DATAPUMP.START_JOB(hdnl);
END;
/

MAP SIEBEL.CX_CORRESP, TARGET SIEBEL.CX_CORRESP, FILTER ( @GETENV('TRANSACTION', 'CSN') > 13135339586607);


DECLARE
hdnl NUMBER;
BEGIN
hdnl := DBMS_DATAPUMP.OPEN( operation => 'IMPORT', job_mode => 'TABLE', job_name=>null);
DBMS_DATAPUMP.ADD_FILE( handle => hdnl, filename => 'expdp_CX_CORRESP_%U.dmp', directory => 'DATA_PUMP_DIR', filetype => dbms_datapump.ku$_file_type_dump_file);
DBMS_DATAPUMP.ADD_FILE( handle => hdnl, filename => 'impdp_CX_CORRES.log', directory => 'DATA_PUMP_DIR', filetype => dbms_datapump.ku$_file_type_log_file);
DBMS_DATAPUMP.METADATA_FILTER(hdnl,'SCHEMA_EXPR','IN (''SIEBEL'')');
DBMS_DATAPUMP.METADATA_FILTER(hdnl,'NAME_EXPR','IN (''CX_CORRESP'')');
DBMS_DATAPUMP.set_parallel(handle=>hdnl,degree=>6);
DBMS_DATAPUMP.SET_PARAMETER(handle=>hdnl,name =>'TABLE_EXISTS_ACTION',value => 'REPLACE');
DBMS_DATAPUMP.START_JOB(hdnl);
END;    
/

+++++++++ % completion of export expdb or import impdp +++++++++++++
    set lines 200 pages 2000
    col STATE format a12
    col OWNER_NAME format a14
    col JOB_MODE format a13
    select sid, serial#, sofar, totalwork,
    dp.owner_name, dp.state, dp.job_mode
    from gv$session_longops sl, gv$datapump_job dp
    where sl.opname = dp.job_name and sofar != totalwork;


SELECT OPNAME, SID, SERIAL#, CONTEXT, SOFAR, TOTALWORK, ROUND(SOFAR/TOTALWORK*100,2) "%_COMPLETE"
FROM V$SESSION_LONGOPS WHERE OPNAME in
( select d.job_name from v$session s, v$process p, dba_datapump_sessions d
where p.addr=s.paddr and s.saddr=d.saddr )
AND OPNAME NOT LIKE '%aggregate%' AND 
TOTALWORK != 0 AND SOFAR <> TOTALWORK;

set linesize 800
set pagesize 500
column username format a10
column message format a65
column elapsed_time format a10
column remaining_time format a10
column start_time format a20
column "Blocks statistics" format a40
select sid,username,message, to_char(start_time,'dd-Mon-rr hh24:mi:ss') start_time,TRUNC(sl.elapsed_seconds/60) || ':' || MOD(sl.elapsed_seconds,60) elapsed_time, TRUNC(sl.time_remaining/60) ||':' || MOD(sl.time_remaining,60) remaining_time, ROUND(sl.sofar/sl.totalwork*100, 2) progress_pct from gv$session_longops sl where sl.sid in (select sid from gv$session where status='ACTIVE') and sl.time_remaining<>0 order by 5 ;


— Check current job details 

select x.job_name,b.state,b.job_mode,b.degree
, x.owner_name,z.sql_text, p.message
, p.totalwork, p.sofar
, round((p.sofar/p.totalwork)*100,2) done
, p.time_remaining
from dba_datapump_jobs b 
left join dba_datapump_sessions x on (x.job_name = b.job_name)
left join v$session y on (y.saddr = x.saddr)
left join v$sql z on (y.sql_id = z.sql_id)
left join v$session_longops p ON (p.sql_id = y.sql_id)
WHERE y.module='Data Pump Worker'
AND p.time_remaining > 0;

XXINT_RS / Oracle123

======================================================
Schema refresh datapump
======================================================

set head off
set pages 0
set long 9999999
select  dbms_metadata.get_ddl('USER', 'FOS') || '/' usercreate from DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','JGNANARAJ') FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','JGNANARAJ') FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','JGNANARAJ') FROM DUAL;


set pages 0
set long 9999999
select  dbms_metadata.get_ddl('USER', 'DEBIT') || '/' usercreate from DUAL;

   CREATE USER "DEBIT" IDENTIFIED BY VALUES 'S:B00084BCD9B8646F7EB9BC621A6A63D54
750146421ECFB871E1BEB7F96C7;3540B38909B90386'
      DEFAULT TABLESPACE "DEBIT_DATA"
      TEMPORARY TABLESPACE "TEMP"
      PROFILE "APPLICATION_HIGH_RISK_PROFILE"/

set head off
set pages 0
set long 9999999
select  dbms_metadata.get_ddl('ROLE', 'SSE_ROLE') || '/' usercreate from DUAL;


set head off
set pages 0
set long 9999999
select  dbms_metadata.get_ddl('TYPE', 'BRM10_101') || '/' usercreate from DUAL;


verify log:

select OWNER, OBJECT_TYPE, count (*)  from DBA_OBJECTS where owner in ('BRM_EBPI_RO') group by OWNER, OBJECT_TYPE ;
SELECT count(*)  FROM DBA_OBJECTS WHERE STATUS != 'VALID'  ORDER BY OWNER, OBJECT_TYPE;
 
+++++++ no. of rows processed in import impdp ++++++++++++
select substr(sql_text,instr(sql_text,'into "'),30) table_name,
rows_processed, round((sysdate-to_date(first_load_time,'yyyy-mm-dd hh24:mi:ss'))*24*60,1) minutes,
trunc(rows_processed/((sysdate-to_date(first_load_time,'yyyy-mm-dd hh24:mi:ss'))*24*60)) rows_per_minute
from sys.v_$sqlarea
where sql_text like 'insert %into "%' and command_type = 2 and open_versions > 0;


----total opertions on table

column table_owner format a5
column TABLE_NAME format a30
SELECT TABLE_OWNER, 
   TABLE_NAME, 
   INSERTS,
   UPDATES,
   DELETES
FROM  DBA_TAB_MODIFICATIONS
where TABLE_OWNER='&TABLE_OWNER' and table_name='&table_name';
--group by table_owner,table_name
order by 4;



********* To check table lock ***********
SELECT A.SID, A.SERIAL#,A.USERNAME
FROM gV$SESSION A, gV$LOCKED_OBJECT B, DBA_OBJECTS C 
WHERE B.OBJECT_ID = C.OBJECT_ID 
AND A.SID = B.SESSION_ID
AND OBJECT_NAME='&TABLENAME';
INVOICE_HEADER


set linesize 300
col U_NAME format a15
col OBJ_OWNER format a15
col OBJECT_NAME format a20
col OSUSER format a10
col MODE_HELD format a20
SELECT username U_NAME, owner OBJ_OWNER,
object_name, object_type, s.osuser,
DECODE(l.block,
  0, 'Not Blocking',
  1, 'Blocking',
'Global') STATUS,
DECODE(v.locked_mode,
    0, 'None',
    1, 'Null',
    2, 'Row-S (SS)',
    3, 'Row-X (SX)',
   4, 'Share',
   5, 'S/Row-X (SSX)',
    6, 'Exclusive', TO_CHAR(lmode)
 ) MODE_HELD
FROM gv$locked_object v, dba_objects d,
gv$lock l, gv$session s
WHERE owner=('SECS5')
AND OBJECT_NAME='ARACCTHOLDERAUTH'
AND v.object_id = d.object_id
AND (v.object_id = l.id1)
AND v.session_id = s.sid
ORDER BY username, session_id;

**************************************
******* Cursor related queries **********

SELECT s.sid,oc.user_name,oc.SQL_ID,oc.HASH_VALUE,s.MACHINE,s.PROGRAM,s.LOGON_TIME,s.STATE,s.status
 FROM v$open_cursor oc, v$session s
 WHERE OC.sid = S.sid and CURSOR_TYPE='OPEN';
 
select count(*) current_open_cursor from v$open_cursor where CURSOR_TYPE='OPEN';

*********************************
ORA-8104
http://oracle-info.com/2013/01/16/ora-8104-this-index-object-xxxx-is-being-online-built-or-rebuilt/

alter replicat RS5LBILL extseqno 57768 extrba 320394590. 
************ plan****************

Method 1: If we know SQL_ID

    select plan_table_output from table(dbms_xplan.display_cursor('&sql_id'));
select * from TABLE(dbms_xplan.display_awr('&sql_id'));
70zvwz5zm46mr
Method 2: If we know SQL

explain plan for SSELECT SUPCAT_PRD_USRDEFATR.value                             AS
       "Support Category",
       PRODUCT.part_num                                       AS
       "Item Number (SKU)",
       PRODUCT.name                                           AS "Product Name",
       PRODUCT.desc_text,
       PRODUCT.status_cd                                      AS "Item Status",
       ACCT_RULE_PRD_USRDEFATR.value                          AS
       "Accounting Rule",
       PRODUCT.uom_cd                                         AS
       "Unit of Measure";

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());

***** How to purge old data from sys.$aud table***********************

-- Checking size of sys.aud$ table :
++++++++++++++++++++++++++++++++++++++++++++++++

SQL> select OWNER,SEGMENT_NAME,BYTES/1024/1024 size_in_gb from dba_segments where OWNER='SYS' and SEGMENT_NAME='AUD$';

OWNER                          SEGMENT_NAME             SIZE_IN_GB
------------------------------ ------------------------ ----------
SYS                            AUD$                        452



Checking no. od days of data in sys.aud# :
++++++++++++++++++++++++++++++++++++++++++++++++++++++


SQL> select min(NTIMESTAMP#) from sys.aud$;

MIN(NTIMESTAMP#)
------------------------------
30-MAR-12 06.42.18.375298 PM

SQL> select max(NTIMESTAMP#) from sys.aud$;

MAX(NTIMESTAMP#)
-------------------------------
12-NOV-14 03.29.06.229288 PM


Delete data older than 90 days:
++++++++++++++++++++++++++++++++++++

delete from sys.aud$ where ntimestamp# < sysdate-90;

**********************************************************************************


**************** ADRCI ***************
adrci> show incident

adrci> show incidents -last 10

adrci> show incidents -all

ADR Home = /u01/app/oracle/diag/rdbms/*****/*******:
*************************************************************************
INCIDENT_ID          PROBLEM_KEY                                                 CREATE_TIME
-------------------- ----------------------------------------------------------- ----------------------------------------
197007               ORA 445                                                     2014-07-24 20:02:26.324000 -05:00
197207               ORA 445                                                     2014-07-24 20:04:26.191000 -05:00
455927               ORA 7445 [opiaba()+708]                                     2014-10-09 17:36:05.354000 -05:00
455928               ORA 600 [kghGetHpSz1]                                       2014-10-09 17:36:40.498000 -05:00
455167               ORA 600 [17147]                                             2014-10-09 19:48:32.964000 -05:00
694281               ORA 7445 [opiaba()+708]                                     2015-04-07 17:54:13.775000 -05:00
692825               ORA 600 [17147]                                             2015-04-07 18:06:24.598000 -05:00

*********How to create package:

Based on Incident
adrci>IPS CREATE PACKAGE INCIDENT <incident_number>

adrci>IPS CREATE PACKAGE ( For creating empty package)

Based on Problem
adrci>IPS CREATE PACKAGE PROBLEM <problem_ID>

Based on time interval
adrci>IPS CREATE PACKAGE SECONDS sec
adrci>IPS CREATE PACKAGE TIME 'start_time' TO 'end_time'

*******Adding Incidents and files to the logical package :

adrci>IPS ADD INCIDENT incident_number PACKAGE package_number
adrci>IPS ADD FILE filespec PACKAGE package_number


***********Generate a physical incident package ********************
Once you have created a logical package using one of the above methods, next step is to generate a physical package
adrci>IPS GENERATE PACKAGE package_number IN path


You can also create logical package and generate physical package with just one command 
adrci>IPS PACK INCIDENT <incident_id> IN <directory>

*********************************************************************************************************
************ How to drop all object from a schema *************

select owner,object_type,count(object_name) from dba_objects where owner='<schema_name>' group by owner,object_type;

set heading off
set pages 50000
select 'drop table '||owner||'.'||table_name||' cascade constraints;' from dba_tables where owner = '<schema_name>';

purge dba_recyclebin;

select owner,object_type,count(object_name) from dba_objects where owner='<schema_name>' group by owner,object_type;

select 'drop '||object_type||' '|| object_name||  DECODE(OBJECT_TYPE,'TABLE',' CASCADE CONSTRAINTS;',';')  from dba_objects where owner = '<schema_name>' and object_type IN ('SYNONYM','SEQUENCE','PROCEDURE','VIEW');

alter session set current_schema=<schema_name>;

Now drop all the objects with the previous scripts.

***************************************************************

********* How to get list of SQLs that running for a particular tables for some time period *****

Step-1:  Check for snap id for the particular day using below query.
 
SELECT SNAP_ID,BEGIN_INTERVAL_TIME,END_INTERVAL_TIME FROM DBA_HIST_SNAPSHOT order by SNAP_ID;
 
Step-2:  With the help of snap id, run below sql to get output in html format.
 
SET PAGES 5000 TERM OFF FEEDBACK OFF MARKUP HTML ON PREFORMAT OFF ENTMAP ON
set verify off
spool June29_sql_detail.html
 
set lines 300
set long 9999999
select a.SESSION_ID, a.SAMPLE_TIME, a.USER_ID, (select username from dba_users where a.user_id=user_id) as username, b.SQL_ID, b.sql_text
from DBA_HIST_ACTIVE_SESS_HISTORY a, dba_hist_sqltext b 
where a.sql_id=b.sql_id and upper(b.sql_text) like '%CACHE_STATUS%' 
and a.snap_id>=8022 and a.snap_id<=8047;
spool off
set markup html off
EOF
 
Here 53363 is the begin snap id and 53386 the last snap id for Apr 20th.

***********************************************************************************************
************ BLOCK CHANGE TRACKING******************
When using Oracle block change tracking we see this procedure.  As data blocks change, the Change Tracking Writer (CTWR) background process tracks the changed blocks in a private area of memory. 

When a commit is issued against the data block, the block change tracking information is copied to a shared area in Large Pool called the CTWR buffer. During the checkpoint, the CTWR process writes the information from the CTWR RAM buffer to the change-tracking file.

SQL> alter database enable block change tracking;

SQL> alter database enable block change tracking using file '/u01/app/oracvle/mysid/data/block_change_tracking.dbf';

To disable this feature, you issue this command:

SQL> alter database disable block change tracking;

To monitor the status of block change tracking, you type:

SQL> select filename, status, bytes from   v$block_change_tracking;

STATUS       FILE                          BYTES
-----------  ----------------------------  --------------
ENABLED      /dba/backup/01_mf_yzmrr7.chg  10,000,000

We can view the size of the CTWR dba buffer by looking at v$sgastat:

SELECT * FROM v$sgastat WHERE name like 'CTWR%'; 


************* Enable/Disable STats gather ****************

BEGIN
dbms_auto_task_admin.enable(client_name => 'auto optimizer stats collection', operation => NULL, window_name => NULL);
dbms_auto_task_admin.enable(client_name => 'auto space advisor', operation => NULL, window_name => NULL);
dbms_auto_task_admin.enable(client_name => 'sql tuning advisor', operation => NULL, window_name => NULL);
END;


************************************************************************

ORA-01591: LOCK HELD BY IN-DOUBT DISTRIBUTED TRANSACTION STRING

select * from pending_trans$;

Select * from dba_2pc_pending where local_tran_id='606.36.301120';

Here, according to the situation before the commit is issued after the rollback.

commit  force  '606.36.301120';
rollback force  '606.36.301120';

https://anargodjaev.wordpress.com/2013/12/24/ora-01591-lock-held-by-in-doubt-distributed-transaction/


*********************** OPATCH ********************
cd $ORACLE_HOME/OPatch
./opatch lsinventory -detail >> Opatch.lst


aws s3 cp s3://upgrade-software/12.35_p6880880_190000_Linux-x86-64.zip .
unzip 12.35_p6880880_190000_Linux-x86-64.zip -d /opt/oracle/product/19.3.0/
cp $ORACLE_HOME/rdbms/admin/shrept.lst /opt/oracle/product/19.3.0/network/admin/shrept.lst
relink all
 export PATH=$ORACLE_HOME/OPatch:$PATH
 
 
 Attach Oracle_HOME
 
 cd $ORACLE_HOME/oui/bin
./runInstaller -invPtrLoc /u01/app/oracle/product/19.3.0/oraInst.loc -attachHome ORACLE_HOME=/u01/app/oracle/product/19.3.0/ ORACLE_HOME_NAME="Ora19cHome"


./runInstaller -invPtrLoc /u01/app/oracle/product/11.2.0.4/oraInst.loc -attachHome ORACLE_HOME=/u01/app/oracle/product/11.2.0.4/ ORACLE_HOME_NAME="Ora11gHome"


COL comments    FOR A70
COL action_time FOR A30
COL action      FOR A12
COL version     FOR A30
-- Historical pre 12c info
SELECT comments,  action, TO_CHAR(action_time, 'DD-MON-YYYY HH24:MI:SS') AS action_time
FROM   sys.registry$history
WHERE  comments like '%RU%'
AND    action = 'APPLY'
UNION ALL 
-- 12c registry for sqlpatch
SELECT description,  action, TO_CHAR(action_time, 'DD-MON-YYYY HH24:MI:SS') AS action_time
FROM   sys.dba_registry_sqlpatch
WHERE  description like 'Database RU%'
AND    action = 'APPLY';


export ORACLE_HOME=/data/oracle/Middleware13.4/
/data/oracle/Middleware13.4/OMSPatcher/omspatcher apply /data/software/OMS_Patch/34860945 -analyze
/data/oracle/Middleware13.4/OMSPatcher/omspatcher apply /data/software/OMS_patch/34860945 -analyze -invPtrLoc /data/oracle/Middleware13.4/oraInst.loc  OMSPatcher.OMS_DISABLE_HOST_CHECK=true
 /data/oracle/Middleware13.4/OMSPatcher/omspatcher apply -invPtrLoc /data/oracle/Middleware13.4/oraInst.loc  OMSPatcher.OMS_DISABLE_HOST_CHECK=true
 
 EmPrd13c_Web  EmPrd13c_Web 
 
 /data/oracle/gc_inst13.4/user_projects/domains/GCDomain/servers/EMGC_ADMINSERVER/security
 
*****************************************************
#########################dba_registry#################
set lines 999 pages 9999 long 99999
col COMP_ID format a15
col COMP_NAME format a50
 select COMP_ID,COMP_NAME,VERSION,STATUS from dba_registry;
 
*****************************************************

***** SYS password change:

select * from user$ where name='SYS';


mv orapwprodbop1 orapwprodbop1.bck.0122


orapwd file=orapwptbirp12 password=ind1ant3l3v1s10n entries=10;

******** DB link ***********
set lines 200 pages 2000
col HOST format a10
col DB_LINK format a10
col HOST format a10
col OWNER format a10
col DB_LINK format a15
select * from dba_db_links where DB_LINK='VALIDATE';

OWNER           DB_LINK                             USERNAME             HOST                                     CREATED
--------------- ----------------------------------- -------------------- ---------------------------------------- ---------
PUBLIC          PHLODS003D.WORLD                    ALLPOINTS            t2a2                                     03-FEB-14


select DBMS_METADATA.GET_DDL('MATERIALIZED_VIEW','PIM_FVROLLUP_MV','BOADMIN') from dual;


select DBMS_METADATA.GET_DDL('PROCEDURE','SEBL_PIM_PROD_ATTR','FOS') from dual;

select DBMS_METADATA.GET_DDL('VIEW','DIM_PRODUCT','FOS') from dual;

select DBMS_METADATA.GET_DDL('PROCEDURE','CREATE_DB_LINK','DBADMIN') from dual;


 set pages 999
 set long 90000
 set lin 120
 SELECT 'SELECT dbms_metadata.get_ddl(''DB_LINK'',''' || db_link || ''',''' || owner || ''') as "Your DB Link DDL here" FROM dual;' AS "Execute below Query for DDL"
FROM dba_db_links WHERE db_link IN ('SIEBEL_DEV19C'); <<-- Enter your DB Link Name

CREATE PUBLIC DATABASE LINK "PHLODS003D.WORLD" CONNECT TO "ALLPOINTS" IDENTIFIED BY VALUES ':1' USING 't2a2'

  CREATE DATABASE LINK "RPT_BRM_CRM"
   CONNECT TO "RPT" IDENTIFIED BY VALUES ':1'
   USING 'crmpds01'

CREATE PUBLIC DATABASE LINK "RPT_BRM_CRM"
   CONNECT TO "RPT" IDENTIFIED BY VALUES ''
   USING '(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)(HOST = crmpds01.cp3wcv9k5vkc.us-west-2.rds.amazonaws.com)(PORT = 1441))(LOAD_BALANCE = yes)(CONNECT_DATA =(SERVER = DEDICATED)(SERVICE_NAME = crmprf01)(UR=A)))

CREATE PUBLIC DATABASE LINK "RPT_BRM_CRM"
   CONNECT TO "RPT" IDENTIFIED BY VALUES 'A54E6981D3D2517E'
   USING '(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)(HOST = crmpds01.cp3wcv9k5vkc.us-west-2.rds.amazonaws.com)(PORT = 1441))(LOAD_BALANCE = yes)(CONNECT_DATA =(SERVER = DEDICATED)(SERVICE_NAME = crmpds01)(UR=A)))';
   
  Intuit01_1234 
   CREATE DATABASE LINK "RPT_BRM_CRM"
   CONNECT TO "RPT" IDENTIFIED BY Intuit_123
   USING '(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)(HOST = crmpds01.cp3wcv9k5vkc.us-west-2.rds.amazonaws.com)(PORT = 1441))(LOAD_BALANCE = yes)(CONNECT_DATA =(SERVER = DEDICATED)(SERVICE_NAME = crmpds01)(UR=A)))';

  CREATE DATABASE LINK "IRDB_LIVE"
   CONNECT TO "ITEM30" IDENTIFIED BY VALUES ':1'
   USING '(DESCRIPTION=(ADDRESS=(PROTOCOL=TCPS)(HOST=trnprdp1.csg4wgdxckaa.us-west-2.rds.amazonaws.com)(PORT=19060))(CONNECT_DATA=(SID=trnprdp1)))'"
   
   
   CREATE DATABASE LINK brmsys  CONNECT TO  SYS$UMF IDENTIFIED BY "Intuit_123" USING '(DESCRIPTION=(FAILOVER=ON) (ADDRESS=(PROTOCOL=TCP)(HOST=brmsys.c2pcid82kthv.us-west-2.rds.amazonaws.com)(PORT=13050)) (CONNECT_DATA=(SERVICE_NAME=brmsys)))';
   
   
CREATE PROCEDURE XXRS.cre_db_lnk AS
BEGIN
    EXECUTE IMMEDIATE 'CREATE DATABASE LINK APPSLINK'
            ||'CONNECT TO XXINT_RS IDENTIFIED BY "intuit#13579"'
            ||'USING ''(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=sysdb.ebizpreprod.int.a.intuit.com)(PORT=16050)) (CONNECT_DATA= (SID=EBIZSYS)))''';
END cre_db_lnk;
/

Exec XXRS.create_db_lnk 

CREATE PROCEDURE BRM01.drop_db_link AS
BEGIN
EXECUTE IMMEDIATE 'drop database link TO_PRODUPG';
END drop_db_link;
/

exec BRM01.drop_db_link


**********************************

select 'alter table '||owner||'.'||table_name|| ' disable constraint ' ||constraint_name||';' from dba_constraints where owner='LDB_OWNER';

select 'alter table '||owner||'.'||table_name|| ' enable constraint ' ||constraint_name||';' from dba_constraints where owner='ENTUSER';

SELECT 'truncate table '|| owner|| '.' || object_name || ' cascade;' FROM dba_objects WHERE owner='LDB_SAND' and OBJECT_TYPE='TABLE';

************** How to unregister database from Catalog ***********

SQL> select db_key,dbid,name from rc_database where name='DELBIDW6';

    DB_KEY DBID NAME
---------- ---------- --------
 136678707 12480768 DELBIDW6

SQL> execute dbms_rcvcat.unregisterdatabase(136678707,12480768);

PL/SQL procedure successfully completed.

SQL> select db_key,dbid,name from rc_database where name='DELBIDW6';

no rows selected

**********************************************************
#############################Table partatin ################################################

TF:

set lines 500
select table_owner,table_name,count(*) from dba_tab_partitions where table_owner not in ('SYS','SYSTEM') group by table_owner,table_name order by TABLE_OWNER;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='XXRS' and table_name='XXDMR_REV_LINES' order by PARTITION_position;


RF:

select table_owner,table_name,count(*) from dba_tab_partitions where table_owner not in ('SYS','SYSTEM') group by table_owner,table_name order by TABLE_OWNER;
select table_owner,table_name,count(*) from dba_tab_partitions where table_owner='RFORT' group by table_owner,table_name order by TABLE_OWNER;

select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='RFORT' and table_name='ARRFSYSAUDITLOG' order by PARTITION_position;

AOK:

select table_owner,table_name,count(*) from dba_tab_partitions where table_owner not in ('SYS','SYSTEM') group by table_owner,table_name order by TABLE_OWNER;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='ARCOT' and table_name='AOK_USER_FLOW_LOG' order by PARTITION_position;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,HIGH_VALUE from dba_tab_partitions where table_owner='ARCOT' and table_name='AOK_USER_AUDIT_LOG' order by PARTITION_position;




 TO list partitons for a specific month. Just replace the month and year.

select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAMe,HIGH_VALUE from dba_tab_partitions where partition_name like '%JUL%14' order by 1;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,subPARTITION_NAME,TABLESPACE_NAMe,HIGH_VALUE from dba_tab_subpartitions where table_name='ARACSLOG' and table_owner='SECS5' and subPARTITION_NAME like '%JUL%';


select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,TABLESPACE_NAMe,HIGH_VALUE from dba_tab_partitions where partition_name like '%JUL%14%' order by 1;
select TABLE_OWNER,TABLE_NAME,PARTITION_NAME,subPARTITION_NAME,TABLESPACE_NAMe,HIGH_VALUE from dba_tab_subpartitions where table_name='ARRFSYSAUDITLOG_3DSECURE_DW' and table_owner='RFORT' and subPARTITION_NAME like '%JUL%14%';


#############################Table partition size################################################
set lines 999 pages 9999 long 99999
col partition_name format a20
SELECT
    partition_name,
    SUM(bytes) / 1024 / 1024 /1024 AS partition_size_gb
FROM
    dba_segments
WHERE
    segment_type = 'TABLE PARTITION'
    AND segment_name = 'XXDMR_REV_SCHEDULES_OUT_P'
GROUP BY
    partition_name;


#######################################Goldengate##############################################
to start the process from the specific SCN and RBA value.

alter replicat RS5LBILL extseqno 64710 extrba 375603706;

ALTER EXTRACT ESYSUIP, THREAD 1, BEGIN 2024-02-20 02:08:00
ALTER EXTRACT E_F_12C, THREAD 2, BEGIN 2018-06-25 09:00:00


alter extract E1BRMDV1  extseqno 1346.
alter extract E_F_12C  extseqno 3094 thread 1
alter extract E_F_12C  extseqno 3921, extrba 0, thread 1.
start E_F_12C.

***************to find the check ping information***************
info E_F_12C  showch.
alter extract E_F_12C  extseqno 3921, extrba 0, thread 1
alter extract E_F_11G  extseqno 4015, extrba 0, thread 2

alter replicat R_F_12C, extseqno 487, extrba 363763372;
START REPLICAT R_F_12C SKIPTRANSACTION
start E_F_12C.

rsync utility. rsync -avze ssh /backup/expdp/secs4_d1 oracle@10.22.44.41:/backup/expdp/.
###########################################################################################

alter table TSYS.ARVELOG truncate partition  TSYS_VELOG_MAY17 UPDATE GLOBAL INDEXES parallel 4;

Drop

alter table SECS2.ARESLOG drop partition  S2ESLOG_APR17 UPDATE GLOBAL INDEXES parallel 4;


set lines 999 pages 9999 long 99999
col TABLE_NAME format a40
col OWNER format a15
col INDEX_NAME format a40
SELECT OWNER, TABLE_NAME,INDEX_NAME, DOMIDX_STATUS, DOMIDX_OPSTATUS,DEGREE, STATUS FROM ALL_INDEXES  WHERE OWNER = '&OWNER' and TABLE_NAME='&TABLE_NAME' ;

select 'alter index '||owner||'.'||index_name||' parallel (degree 1);' from dba_indexes where table_name='XXDMR_REV_SCHEDULES';

select 'alter index '||owner||'.'||index_name||' rebuild index online parallel 64 nologging;' from dba_indexes where table_name='XXDMR_REV_SCHEDULES_OUT';

select 'alter index '||owner||'.'||index_name||' nologging;'  from dba_indexes where table_name='XXDM_ARRANGEMENTS';



Find indexed  columns:
---------------------
col INDEX_NAME format a30
col COLUMN_NAME format a30

SELECT
    aic.index_name,
    aic.column_name,
    aic.column_position,
    ai.uniqueness
FROM
    all_ind_columns aic
JOIN
    all_indexes ai ON aic.index_name = ai.index_name
                  AND aic.table_owner = ai.owner
                  AND aic.table_name = ai.table_name
WHERE
    aic.table_owner = UPPER('&your_table_owner') -- Replace with the owner of the table
    AND aic.table_name = UPPER('&your_table_name') -- Replace with the name of your table
ORDER BY
    aic.index_name,
    aic.column_position;


Index creation date and time:
---------------------------
col owner format a15
col object_name format a20
SELECT
    owner,
    object_name,
    created
FROM
    all_objects
WHERE
    object_type = 'INDEX'
    AND object_name = '&object_name' and OWNER='BRM01';
    
Index usage:
------------

SET lines 999 pages 9999 long 99999
col OPERATION format a15
col OPTIONS format a40
col OBJECT_NAME format a30
SELECT sql_id, child_number, operation, options, object_name FROM v$sql_plan WHERE object_name = 'XXDMR_REV_SCHEDULES';


*************************index size*************************
col SEGMENT_NAME format a30
select segment_name,TABLESPACE_NAME ,segment_type, bytes/1024/1024/1024 size_gb from dba_segments where segment_name = '&segment_name' or segment_name in (select index_name from dba_indexes where table_name='&tablename' and table_owner='&owner');
(**********************************************

OEM Blockout 

export  AGENT_HOME=`cat /etc/oragchomelist|cut -d ":"  -f2`
$AGENT_HOME/bin/emctl  status blackout
$AGENT_HOME/bin/emctl  start blackout PDSRefresh -nodeLevel -d 06:00
echo "Check the status of blockout"
$AGENT_HOME/bin/emctl status blackout
**************************************************

----PROD SQL    
 --GG_REPLICATION  MONITOR 

SQL> select * from gv$session where (sid,serial#)  in (select sid,serial# from gv$gg_apply_server where apply_name='OGG$&REP_NAME');

SQL> select * from gv$session where (sid,serial#)  in (select sid,serial# from gv$gg_apply_receiver where apply_name='OGG$&REP_NAME');

SQL> select * from gv$session where (sid,serial#)  in (select sid,serial# from gv$gg_apply_receiver where apply_name='OGG$&REP_NAME');


------

-----ADD table in exisiting replicat:---

MAP XXRS.XXDMR_REV_LINES, TARGET XXRS.XXDMR_REV_LINES_Q, FILTER ( @GETENV("TRANSACTION", "CSN") > 13224575298219);

********************************************

	SR 3-22941088151 : ORA-01031: insufficient privileges while selecting from View


GRANTEE PRIVILEGE GRA
------------------------------ ---------------------------------------- ---
ITEM30 EXECUTE NO

SQL> grant execute on "ITEM30APP"."FORMULAELEMENT_LIST" to ITEM30 with grant option;

Grant succeeded.

SQL> grant select on ITEM30.offeringpropertytype_v to ITEM30APP WITH GRANT OPTION;
grant select on ITEM30.offeringpropertytype_v to ITEM30APP WITH GRANT OPTION
*
ERROR at line 1:
ORA-01720: grant option does not exist for 'ITEM30APP.RULE_LIST'

1* grant execute on ITEM30APP.RULE_LIST to item30 with grant option
SQL> /

Grant succeeded.

SQL> grant select on ITEM30.offeringpropertytype_v to ITEM30APP WITH GRANT OPTION;
grant select on ITEM30.offeringpropertytype_v to ITEM30APP WITH GRANT OPTION
*
ERROR at line 1:
ORA-01720: grant option does not exist for 'ITEM30APP.ID_LIST'


SQL> select object_type from dba_objects where object_name='ID_LIST';

OBJECT_TYPE
-------------------
SYNONYM
TYPE
SYNONYM
TYPE

SQL> grant execute on ITEM30APP.ID_LIST to ITEM30 with grant option;

Grant succeeded.

SQL> grant select on ITEM30.offeringpropertytype_v to ITEM30APP WITH GRANT OPTION;

Grant succeeded.
##########################################################################
*******************SWAP SPACE Addation in Linux****************************
[ec2-user@pimpdsdb1 ~]$ free -m
              total        used        free      shared  buff/cache   available
Mem:          31211       17041         258       11668       13911        1898
Swap:         10239        2724        7515
[ec2-user@pimpdsdb1 ~]$ swapon -s
Filename				Type		Size	Used	Priority
/var/myswap                            	file	10485756	2790260	-2
sudo dd if=/dev/zero of=/swapfile2 bs=1024M count=93
chmod 600 /swapfile2
sudo mkswap /swapfile2
sudo swapon /swapfile2
sudo swapon -s
free -m
vi /etc/fstab
/swapfile2 swap swap defaults 0 0

dd if=/dev/zero of=/var/myswap bs=1M count=15360
mkswap /var/myswap
swapon /var/myswap
chmod 0600 /var/myswap
***********************************************************************

#Mike-Devlin.com copyright 2003 (this file is free to use)
#
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
	. ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/bin

export PATH
unset USERNAME

ORACLE_BASE=/u01/app/oracle; export ORACLE_BASE
ORACLE_HOME=/u01/app/oracle/product/8.1.7; export ORACLE_HOME
ORACLE_SID=prod1ora; export ORACLE_SID
PATH=$PATH:/u01/app/oracle/product/8.1.7/bin; export PATH
CLASSPATH=.:/u01/app/oracle/product/8.1.7/jdbc/lib/classes111.zip; export CLASSPATH
LD_LIBRARY_PATH=/u01/app/oracle/product/8.1.7/lib; export LD_LIBRARY_PATH
LD_ASSUME_KERNEL=2.2.5; export LD_ASSUME_KERNEL
umask 022esrprf11
******************************************************************************
*****************sequence monitor*********************************************
col SEQUENCE_OWNER format a40
col SEQUENCE_NAME format a30
col MIN_VALUE format a40
col INCREMENT_BY format a5
select SEQUENCE_OWNER,SEQUENCE_NAME,MIN_VALUE,MAX_VALUE,INCREMENT_BY,LAST_NUMBER from dba_sequences order by SEQUENCE_OWNER,SEQUENCE_NAME; where SEQUENCE_OWNER in ('ORDDATA','PARTYREF','TIVO','PRSGATE','INIAPP10','SIUSER','INIAPP15','INIAPP115AWS');

select 'alter sequence '||SEQUENCE_OWNER||'.'|| sequence_name || ' increment by 5000; ' from dba_sequences;
 
select 'alter sequence '||SEQUENCE_OWNER||'.'|| sequence_name || ' increment by 1; ' from dba_sequences;




**********************************Sequence Creation**********************************
CREATE SEQUENCE  "AUTHOROWN"."ROLE_ASSIGNMENT_HISTORY_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 100 NOORDER  NOCYCLE  NOPARTITION;

DROP SEQUENCE "AUTHOWN"."OII_IDGEN_CONSUMER_S";
******************************************************************************
*****************shell script for data generation********************************************
Under /ogg_data/dirsql location

sqlplus -S -L dbadmin/`sudo python $OGG_HOME/dirsql/get_creds.py dbadmin rptpdw2a`@rptpdw2a <<EOF
ALTER SESSION SET NLS_DATE_FORMAT='YYYY-MM-DD HH24:mi:SS';
SET PAGES 0 LINES 32767 TRIMSPOOL ON TRIMOUT ON HEAD OFF FEED OFF
SPOOL DBE-375.csv
select m.user_id, m.realm_id, m.persona_id, i.qbnrole from authown.identity i, authown.membership m where i.qbnrole is not null and i.auth_id = m.persona_id and i.parent_id = m.realm_id
/
SPOOL OFF
EXIT
EOF


Run the script
nohup bash extract-identity-data.sh >/dev/null 2>&1 &

*****************************Sql monitor query execution info ***********************************************  event_billing_payment_cc_t :  2kzxm04qf3s85  , arfgqsfsn2sqa: EVENT_ITEM_TRANSFER_T 

alter session set "_parallel_syspls_obey_force" = FALSE;
   set pagesize 0 echo off timing off linesize 2500 trimspool on trim on long 2000000 longchunksize 2000000 feedback off tab off
   set pagesize 9000
	set feedback on
   SELECT DBMS_SQLTUNE.report_sql_monitor(type => 'TEXT', report_level=>'ALL', SQL_ID=>'&sql_id') AS REPORT FROM DUAL;
   
   alter session set "_parallel_syspls_obey_force" = FALSE;
   set pagesize 0 echo off timing off linesize 2500 trimspool on trim on long 2000000 longchunksize 2000000 feedback off tab off
   set pagesize 9000
	set feedback on
   SELECT DBMS_SQLTUNE.report_sql_monitor(type => 'TEXT', report_level=>'ALL', SQL_ID=>'fqggm8gpwdhqu') AS REPORT FROM DUAL;
   
   1am1sd5pbjb0h


select * from table(dbms_xplan.display_cursor(sql_id=>'53u4k58dyw7bu',CURSOR_CHILD_NO=>0,format=>'TYPICAL +OUTLINE ALIAS'));

2tpfzkk3fjm46
03gd8s72yx3kv

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*************************************************************************************************
monitor*****************************SharedpoolPurging  ***********************************************

Steps for Purging for specific SQL Query from shared pool:

1. Find the SQL id from v$sqlarea view.

select sql_id,sql_text from v$Sqlarea where sql_id like 'c2kr2rjdjhrkn';


gy15vry6f7bpr
OR

select sql_id from v$sqlarea where Plan_hash_value= '1570130517';

2. Find the address and hash value from v$sqlarea after finding sqlid:

select ADDRESS, HASH_VALUE from V$SQLAREA where SQL_ID like '8zmh001ahm7mc';

 ADDRESS           HASH_VALUE
----------------  ----------
000000025AJ44GH0  453351686
3. Purge the SQL Id with purge procedure:

exec DBMS_SHARED_POOL.PURGE ('00000002C8D4C730, 3336800397', 'C');

4. Again verified.

select ADDRESS, HASH_VALUE from V$SQLAREA where SQL_ID like '08pykjv3f724d';

no row found
----------purging of shared pool--------------

select 'exec DBMS_SHARED_POOL.PURGE ('''||ADDRESS||', '|| HASH_VALUE||''',''C'');' from V$SQLAREA where PLAN_HASH_VALUE = '3336800397';

SET SERVEROUTPUT ON
DECLARE
  l_plans_dropped  PLS_INTEGER;
BEGIN
  l_plans_dropped := DBMS_SPM.drop_sql_plan_baseline (
    sql_handle => NULL,
    plan_name  => 'SQL_PLAN_dcuv4rag15cgq2f3c10d5');
  DBMS_OUTPUT.put_line(l_plans_dropped);
END;
/


select SQL_ID,HASH_VALUE,OLD_HASH_VALUE,FULL_PLAN_HASH_VALUE from V$SQLAREA where SQL_ID='bx61fz4r1q21r';
*******************************
history 
alter session set nls_date_format='DD-MON-YYYY HH24:MI:SS';

col OBJECT_OWNER format a40
col OBJECT_NAME format a40

select SQL_ID,PLAN_HASH_VALUE,OBJECT_OWNER,OBJECT_NAME,COST,TIME,TIMESTAMP from DBA_HIST_SQL_PLAN where SQL_ID='6qc6n7t76xjz4';

*******************
Pinning Hash Value
set lines 999 pages 9999 long 99999
col END_INTERVAL_TIME format a25
select executions_delta,EXECUTIONS_TOTAL,buffer_gets_delta,disk_reads_delta ,trunc(cpu_time_delta/1000000,2) cpu_time, trunc(elapsed_time_delta/1000000,2) elap_time,a.SNAP_ID, b.end_interval_time,a.PLAN_HASH_VALUE from sys.WRH$_SQLSTAT a, sys.wrm$_snapshot b
where sql_id='&sql_id' and a.snap_id=b.snap_id and b.end_interval_time >= sysdate-30 order by end_interval_time;


select ADDRESS,HASH_VALUE,SQL_ID from v$sql_plan where SQL_ID='&sql_id';   1500907969   1453978063


BEGIN
	SYS.DBMS_SHARED_POOL.PURGE('0000000DDDF7F7F0 3478587045','C');  
END;
/

set serveroutput on
DECLARE
  l_plans_loaded PLS_INTEGER;
BEGIN
   l_plans_loaded := DBMS_SPM.load_plans_from_cursor_cache(sql_id => '66dkchjnfpava',plan_hash_value=>1115336536);
	DBMS_OUTPUT.put_line('Plans Loaded: ' || l_plans_loaded);
END;
/

var n number
begin
:n:=dbms_spm.load_plans_from_cursor_cache(sql_id=>'&SQL_ID', plan_hash_value=>&PLAN_HASH_VALUE, fixed =>'YES', enabled=>'YES');
end;
/

select count(*), rev_sched_status
from xxrs.xxdmr_rev_lines
where conc_request_id = 626492
AND program_status = 'Submitted'
group by rev_sched_status;

******************************************************************************************************
******************************Grant select on all the tables in schema********************************
create user oex_reporting identified by QAZplm$1;

CREATE PROCEDURE grant_select(
    username VARCHAR2, 
    grantee VARCHAR2)
AS   
BEGIN
    FOR r IN (
        SELECT owner, table_name 
        FROM all_tables 
        WHERE owner = username
    )
    LOOP
        EXECUTE IMMEDIATE 
            'GRANT SELECT ON '||r.owner||'.'||r.table_name||' to ' || grantee;
    END LOOP;
END; 


EXEC grant_select('APEX_190200','XXRS_READONLY');



&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
##############################################################################################################################

##########################################OGG transcations###########################################################
set lines 999 pages 9999 long 99999
cOL OPEN_MODE FOR A10
cOL startup_time for a20
col current_time for a20
col status for a10
col host_name for a35
col db_unique_name for a15
COL SID FOR 999999
COL SERIAL# FOR 9999999
COL SQL_ID FOR A15
COL LOGON_TIME FOR A25
COL SQL_EXEC_START FOR A25
COL MODULE FOR A20
COL PROGRAM FOR A45
COL OSUSER FOR A15
COL MACHINE FOR A55
COL CLIENT_INFO FOR A15
COL SERVICE_NAME FOR A15
COL ACTION FOR A15
COL STATUS FOR A10
COL USERNAME FOR A10
COL "SQL_TEXT" FOR A17


SELECT t1.sid,t1.serial#,t1.sql_id,t1.logon_time,t1.osuser,t1.machine,t1.program,t1.status,t2.XIDUSN,t2.XIDSLOT,t2.XIDSQN,t2.start_time from v$transaction t2 , v$session t1 where t2.XIDSQN IN ('273398') AND t1.saddr = t2.ses_addr;


begin
    rdsadmin.rdsadmin_util.kill(
        sid    => 5959, 
        serial => 5605,
        method => 'IMMEDIATE');
end;
/
****************************************************
RDS to OMS HOST


RDS to OMS host:-

Create or replace FUNCTION fn_check_access(
  p_remote_host in varchar2, 
  p_port_no in integer
 )
  RETURN  number IS

    v_connection   utl_tcp.connection;
BEGIN

    v_connection := utl_tcp.open_connection(REMOTE_HOST=>p_remote_host, REMOTE_PORT=>p_port_no, IN_BUFFER_SIZE=>1024, OUT_BUFFER_SIZE=>1024,   TX_TIMEOUT=>5);
    RETURN 1 ;
EXCEPTION
   WHEN others THEN
       return sqlcode ;
END fn_check_access;
/

#############  Step 2: Check connectivity from RDS to OMS Host and port   #################
(Check if 3872 is the correct OMS port)

select fn_check_access ('10.72.62.205', 3872) from dual;


__________________________________________________________________
-----------------------SQL Profiles copy *************************

SQL> select SQL_HANDLE, PLAN_NAME from dba_sql_plan_baselines;

select username,default_tablespace from dba_users where username='OGGOWN';

BEGIN
DBMS_SPM.CREATE_STGTAB_BASELINE(
table_name => 'SPM_STAGETAB01',
table_owner => 'OGGOWN',
tablespace_name => 'OGGDATA');
END;
/


set serveroutput on
DECLARE
x number;
BEGIN
x := DBMS_SPM.PACK_STGTAB_BASELINE('SPM_STAGETAB01', 'OGGOWN');
dbms_output.put_line(to_char(x) || ' plan baselines packed');
END;
/


nohup expdp userid="'/ as sysdba'" directory=IMPORT dumpfile=sql_baseline.dmp logfile=sql_baseline.log tables=OGGOWN.SPM_STAGETAB01 > sql_baseline_01.log &

BEGIN
DBMS_FILE_TRANSFER.GET_FILE(
source_directory_object => 'DATA_PUMP_DIR',
source_file_name => 'sql_baseline.dmp',
Source_database => 'MIGRATION',
destination_directory_object => 'DATA_PUMP_DIR',
destination_file_name => 'sql_baseline.dmp'
);
END;
/


nohup impdp dbadmin/Intuit_Rev@rvsprf01_RDS directory=DATA_PUMP_DIR dumpfile=sql_baseline.dmp logfile=imp_sql_baseline.log > imp_sql_baseline.log &


alter session set current_schema=OGGOWN;

set serveroutput on
DECLARE
x number;
BEGIN
x := DBMS_SPM.UNPACK_STGTAB_BASELINE('SPM_STAGETAB01', 'OGGOWN');
dbms_output.put_line(to_char(x) || ' plan baselines unpacked');
END;
/


SELECT rdsadmin.rdsadmin_s3_tasks.download_from_s3(
      p_bucket_name    =>  'upgrade-software', 
      p_s3_prefix      =>  'sql_baseline.dmp', 
      p_directory_name =>  'DATA_PUMP_DIR') 
   AS TASK_ID FROM DUAL; 
   
   
   1686675546500-2507
   
   SELECT text FROM table(rdsadmin.rds_file_util.read_text_file('BDUMP','dbtask-1686680681786-26295.log')); 



&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&To Find recommended SGA&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

COLUMN finding_time      FOR a20    HEAD 'Finding Time'
COLUMN current_target_mb FOR 999,999 HEAD 'Current SGA|Target (MB)'
COLUMN advised_target_mb FOR 999,999 HEAD 'Advised SGA|Target (MB)'

BREAK ON REPORT
COMPUTE maximum LABEL 'Recommended Min. SGA' OF advised_target_mb ON report

SELECT TO_CHAR( al.execution_start, 'dd Mon yyyy HH24:MI:SS') AS finding_time,
       aa.num_attr1/1048576 AS current_target_mb,
       aa.num_attr2/1048576 AS advised_target_mb
  FROM dba_advisor_actions  aa,
       dba_advisor_findings af,
       dba_advisor_log      al
 WHERE 1=1
   AND al.owner          = af.owner
   AND al.task_name      = af.task_name
   AND aa.owner          = af.owner
   AND aa.task_name      = af.task_name
   AND aa.execution_name = af.execution_name
   AND af.finding_name   = 'Undersized SGA'
   AND aa.attr1          = 'sga_target'
 ORDER
    BY al.execution_start
;


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&To Find Active Queries SGA&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


COL SID FOR 999999
COL SERIAL# FOR 9999999
COL SQL_ID FOR A15
COL LOGON_TIME FOR A25
COL SQL_EXEC_START FOR A25
COL MODULE FOR A25
COL PROGRAM FOR A25
COL OSUSER FOR A15
COL MACHINE FOR A55
COL CLIENT_INFO FOR A15
COL SERVICE_NAME FOR A15
COL ACTION FOR A15
COL STATUS FOR A10
COL USERNAME FOR A10
set lines 300 pages 100
SELECT * FROM (SELECT status,sid,SESSION_SERIAL# as Serial,username,sql_id,SQL_PLAN_HASH_VALUE, MODULE,program, TO_CHAR(sql_exec_start,'DD-MON-YYYY hh24:mi:ss') AS sql_exec_start, ROUND(elapsed_time/1000000) AS "Elapsed (s)", ROUND(cpu_time/1000000) AS "CPU (s)", substr(sql_text,1,30) sql_text FROM gv$sql_monitor where status='EXECUTING' and module not like '%emagent%' ORDER BY sql_exec_start  desc);

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
=============================postgres connection===========================
select max_conn,used,res_for_super,max_conn-used-res_for_super res_for_normal 
from 
  (select count(*) used from pg_stat_activity) t1,
  (select setting::int res_for_super from pg_settings where name=$$superuser_reserved_connections$$) t2,
  (select setting::int max_conn from pg_settings where name=$$max_connections$$) t3;



Sequence Replication
I would recommend that you do NOT include sequences in OGG replication and include updating sequences as a cutover task.
Why? Because OGG Replicats do not perform very well applying sequence updates on the target database
Why? Because sequence updates are considered a 'barrier' transaction. A barrier transaction is one that is so important that OGG stops doing any other DML work so it can update the sequence before it moves on.
If you have a bunch of busy sequences, you could see your PR lagging


incresing xfs fs:
==================

xfs_growfs /mount/point -D size

===========================To find insert/update/delete details =============================
alter session set nls_date_format='DD-MON-YYYY HH24:MI:SS';
col table_owner format a15
col table_name  format a60
SELECT TIMESTAMP, OBJ_NAME, ACTION_NAME, COUNT(*) AS OPERATION_COUNT FROM DBA_AUDIT_TRAIL WHERE OWNER = '&OWNER' AND ACTION_NAME IN ('INSERT', 'UPDATE', 'DELETE') GROUP BY TIMESTAMP, OBJ_NAME, ACTION_NAME ORDER BY TIMESTAMP;
select table_owner,table_name,inserts,updates,deletes,TIMESTAMP from dba_tab_modifications  where table_name = '&table_name' and table_owner='&table_owner';
select table_owner,table_name,inserts,updates,deletes,TIMESTAMP from dba_tab_modifications  where table_owner='&table_owner';



select distinct 
p.name sql_profile_name,
s.sql_id
from 
dba_sql_profiles p,
DBA_HIST_SQLSTAT s
where
p.name=s.sql_profile
 and sql_id='&sql_id';
 
 
 ================================================================================================
  ==============================SQL ADVISOR FROM AWR  ============================== =============
set lines 999 pages 9999 long 99999
select a.instance_number inst_id, a.snap_id,a.plan_hash_value, to_char(begin_interval_time,'dd-mon-yy hh24:mi') btime, abs(extract(minute from (end_interval_time-begin_interval_time)) + extract(hour from (end_interval_time-begin_interval_time))*60 + extract(day from (end_interval_time-begin_interval_time))*24*60) minutes,
executions_delta executions, round(ELAPSED_TIME_delta/1000000/greatest(executions_delta,1),4) "avg duration (sec)" from dba_hist_SQLSTAT a, dba_hist_snapshot b
where sql_id='&sql_id' and a.snap_id=b.snap_id and a.instance_number=b.instance_number order by snap_id desc, a.instance_number;



DECLARE
  l_sql_tune_task_id  VARCHAR2(100);
BEGIN
  l_sql_tune_task_id := DBMS_SQLTUNE.create_tuning_task (
                          begin_snap  => 1252, 
                          end_snap    => 1253,
                          sql_id      => '5sw41h9gdyqca',
                          scope       => DBMS_SQLTUNE.scope_comprehensive,
                          time_limit  => 600,
                          task_name   => '5sw41h9gdyqca_AWR_tuning_task',
                          description => 'Tuning task for statement 5sw41h9gdyqca  in AWR');
  DBMS_OUTPUT.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);
END;
/

EXEC DBMS_SQLTUNE.execute_tuning_task(task_name => '5sw41h9gdyqca_AWR_tuning_task');


    SET LONG 10000000;
    SET PAGESIZE 100000000
    SET LINESIZE 200
    SELECT DBMS_SQLTUNE.report_tuning_task('5sw41h9gdyqca_AWR_tuning_task') AS recommendations FROM dual;
    SET PAGESIZE 24

 ================================================================================================
  ==============================SQL ADVISOR FROM Cursor  ============================== =============
  
Create tuning task

set long 1000000000
DECLARE
l_sql_tune_task_id VARCHAR2(100);
BEGIN
l_sql_tune_task_id := DBMS_SQLTUNE.create_tuning_task (
sql_id => '987rpv25vb09j',
scope => DBMS_SQLTUNE.scope_comprehensive,
time_limit => 500,
task_name => '987rpv25vb09j_tuning_task_1',
description => 'Tuning task for statement 987rpv25vb09j');
DBMS_OUTPUT.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);
END;
/

Execute tuning task

EXEC DBMS_SQLTUNE.execute_tuning_task(task_name => '987rpv25vb09j_tuning_task_1');

Generate report

SET LONG 10000000;
SET PAGESIZE 100000000
SET LINESIZE 200
SELECT DBMS_SQLTUNE.report_tuning_task('987rpv25vb09j_tuning_task_1') AS recommendations FROM dual;
SET PAGESIZE 24

 ================================================================================================
  ============================== Procedures and packes backup in Oracle ============================== =============

-- Connect to the database as a user with appropriate privileges
sqlplus username/password@database

-- Set the output file
SET LONG 100000
SET PAGESIZE 0
SET LINESIZE 200
SET TRIMSPOOL ON
SPOOL backup_packages_and_procedures.sql

-- Get DDL for all packages
SELECT DBMS_METADATA.GET_DDL('PACKAGE', package_name, owner)
FROM all_objects
WHERE object_type = 'PACKAGE'
AND owner = 'XXRS';

-- Get DDL for all procedures
SELECT DBMS_METADATA.GET_DDL('PROCEDURE', object_name, owner)
FROM all_objects
WHERE object_type = 'PROCEDURE'
AND owner = 'XXRS';

-- Close the spool
SPOOL OFF